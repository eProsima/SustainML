// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file types.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "types.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>




NodeStatus::NodeStatus()
{
    // m_node_status com.eprosima.idl.parser.typecode.EnumTypeCode@2f490758
    m_node_status = ::NODE_INACTIVE;
    // m_task_status com.eprosima.idl.parser.typecode.EnumTypeCode@101df177
    m_task_status = ::TASK_WAITING;
    // m_error_code com.eprosima.idl.parser.typecode.EnumTypeCode@166fa74d
    m_error_code = ::NO_ERROR;
    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@40f08448
    m_task_id = 0;
    // m_error_description com.eprosima.idl.parser.typecode.StringTypeCode@276438c9
    m_error_description ="";
    // m_node_name com.eprosima.idl.parser.typecode.StringTypeCode@588df31b
    m_node_name ="";

}

NodeStatus::~NodeStatus()
{






}

NodeStatus::NodeStatus(
        const NodeStatus& x)
{
    m_node_status = x.m_node_status;
    m_task_status = x.m_task_status;
    m_error_code = x.m_error_code;
    m_task_id = x.m_task_id;
    m_error_description = x.m_error_description;
    m_node_name = x.m_node_name;
}

NodeStatus::NodeStatus(
        NodeStatus&& x)
{
    m_node_status = x.m_node_status;
    m_task_status = x.m_task_status;
    m_error_code = x.m_error_code;
    m_task_id = x.m_task_id;
    m_error_description = std::move(x.m_error_description);
    m_node_name = std::move(x.m_node_name);
}

NodeStatus& NodeStatus::operator =(
        const NodeStatus& x)
{

    m_node_status = x.m_node_status;
    m_task_status = x.m_task_status;
    m_error_code = x.m_error_code;
    m_task_id = x.m_task_id;
    m_error_description = x.m_error_description;
    m_node_name = x.m_node_name;

    return *this;
}

NodeStatus& NodeStatus::operator =(
        NodeStatus&& x)
{

    m_node_status = x.m_node_status;
    m_task_status = x.m_task_status;
    m_error_code = x.m_error_code;
    m_task_id = x.m_task_id;
    m_error_description = std::move(x.m_error_description);
    m_node_name = std::move(x.m_node_name);

    return *this;
}

bool NodeStatus::operator ==(
        const NodeStatus& x) const
{

    return (m_node_status == x.m_node_status && m_task_status == x.m_task_status && m_error_code == x.m_error_code && m_task_id == x.m_task_id && m_error_description == x.m_error_description && m_node_name == x.m_node_name);
}

bool NodeStatus::operator !=(
        const NodeStatus& x) const
{
    return !(*this == x);
}

size_t NodeStatus::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t NodeStatus::getCdrSerializedSize(
        const NodeStatus& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.error_description().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.node_name().size() + 1;


    return current_alignment - initial_alignment;
}

void NodeStatus::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_node_status;
    scdr << (uint32_t)m_task_status;
    scdr << (uint32_t)m_error_code;
    scdr << m_task_id;
    scdr << m_error_description.c_str();
    scdr << m_node_name.c_str();

}

void NodeStatus::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_node_status = (Status)enum_value;
    }

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_task_status = (TaskStatus)enum_value;
    }

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_error_code = (ErrorCode)enum_value;
    }

    dcdr >> m_task_id;
    dcdr >> m_error_description;
    dcdr >> m_node_name;
}

/*!
 * @brief This function sets a value in member node_status
 * @param _node_status New value for member node_status
 */
void NodeStatus::node_status(
        Status _node_status)
{
    m_node_status = _node_status;
}

/*!
 * @brief This function returns the value of member node_status
 * @return Value of member node_status
 */
Status NodeStatus::node_status() const
{
    return m_node_status;
}

/*!
 * @brief This function returns a reference to member node_status
 * @return Reference to member node_status
 */
Status& NodeStatus::node_status()
{
    return m_node_status;
}

/*!
 * @brief This function sets a value in member task_status
 * @param _task_status New value for member task_status
 */
void NodeStatus::task_status(
        TaskStatus _task_status)
{
    m_task_status = _task_status;
}

/*!
 * @brief This function returns the value of member task_status
 * @return Value of member task_status
 */
TaskStatus NodeStatus::task_status() const
{
    return m_task_status;
}

/*!
 * @brief This function returns a reference to member task_status
 * @return Reference to member task_status
 */
TaskStatus& NodeStatus::task_status()
{
    return m_task_status;
}

/*!
 * @brief This function sets a value in member error_code
 * @param _error_code New value for member error_code
 */
void NodeStatus::error_code(
        ErrorCode _error_code)
{
    m_error_code = _error_code;
}

/*!
 * @brief This function returns the value of member error_code
 * @return Value of member error_code
 */
ErrorCode NodeStatus::error_code() const
{
    return m_error_code;
}

/*!
 * @brief This function returns a reference to member error_code
 * @return Reference to member error_code
 */
ErrorCode& NodeStatus::error_code()
{
    return m_error_code;
}

/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void NodeStatus::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t NodeStatus::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& NodeStatus::task_id()
{
    return m_task_id;
}

/*!
 * @brief This function copies the value in member error_description
 * @param _error_description New value to be copied in member error_description
 */
void NodeStatus::error_description(
        const std::string& _error_description)
{
    m_error_description = _error_description;
}

/*!
 * @brief This function moves the value in member error_description
 * @param _error_description New value to be moved in member error_description
 */
void NodeStatus::error_description(
        std::string&& _error_description)
{
    m_error_description = std::move(_error_description);
}

/*!
 * @brief This function returns a constant reference to member error_description
 * @return Constant reference to member error_description
 */
const std::string& NodeStatus::error_description() const
{
    return m_error_description;
}

/*!
 * @brief This function returns a reference to member error_description
 * @return Reference to member error_description
 */
std::string& NodeStatus::error_description()
{
    return m_error_description;
}
/*!
 * @brief This function copies the value in member node_name
 * @param _node_name New value to be copied in member node_name
 */
void NodeStatus::node_name(
        const std::string& _node_name)
{
    m_node_name = _node_name;
}

/*!
 * @brief This function moves the value in member node_name
 * @param _node_name New value to be moved in member node_name
 */
void NodeStatus::node_name(
        std::string&& _node_name)
{
    m_node_name = std::move(_node_name);
}

/*!
 * @brief This function returns a constant reference to member node_name
 * @return Constant reference to member node_name
 */
const std::string& NodeStatus::node_name() const
{
    return m_node_name;
}

/*!
 * @brief This function returns a reference to member node_name
 * @return Reference to member node_name
 */
std::string& NodeStatus::node_name()
{
    return m_node_name;
}

size_t NodeStatus::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

     

     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4) + 255 + 1;
     

    return current_align;
}

bool NodeStatus::isKeyDefined()
{
    return true;
}

void NodeStatus::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        scdr << m_task_id;
        scdr << m_node_name.c_str();
      
}



NodeControl::NodeControl()
{
    // m_cmd_node com.eprosima.idl.parser.typecode.EnumTypeCode@17776a8
    m_cmd_node = ::NO_CMD_NODE;
    // m_cmd_task com.eprosima.idl.parser.typecode.EnumTypeCode@69a10787
    m_cmd_task = ::NO_CMD_TASK;
    // m_target_node com.eprosima.idl.parser.typecode.StringTypeCode@2d127a61
    m_target_node ="";
    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2bbaf4f0
    m_task_id = 0;
    // m_source_node com.eprosima.idl.parser.typecode.StringTypeCode@11c20519
    m_source_node ="";

}

NodeControl::~NodeControl()
{





}

NodeControl::NodeControl(
        const NodeControl& x)
{
    m_cmd_node = x.m_cmd_node;
    m_cmd_task = x.m_cmd_task;
    m_target_node = x.m_target_node;
    m_task_id = x.m_task_id;
    m_source_node = x.m_source_node;
}

NodeControl::NodeControl(
        NodeControl&& x)
{
    m_cmd_node = x.m_cmd_node;
    m_cmd_task = x.m_cmd_task;
    m_target_node = std::move(x.m_target_node);
    m_task_id = x.m_task_id;
    m_source_node = std::move(x.m_source_node);
}

NodeControl& NodeControl::operator =(
        const NodeControl& x)
{

    m_cmd_node = x.m_cmd_node;
    m_cmd_task = x.m_cmd_task;
    m_target_node = x.m_target_node;
    m_task_id = x.m_task_id;
    m_source_node = x.m_source_node;

    return *this;
}

NodeControl& NodeControl::operator =(
        NodeControl&& x)
{

    m_cmd_node = x.m_cmd_node;
    m_cmd_task = x.m_cmd_task;
    m_target_node = std::move(x.m_target_node);
    m_task_id = x.m_task_id;
    m_source_node = std::move(x.m_source_node);

    return *this;
}

bool NodeControl::operator ==(
        const NodeControl& x) const
{

    return (m_cmd_node == x.m_cmd_node && m_cmd_task == x.m_cmd_task && m_target_node == x.m_target_node && m_task_id == x.m_task_id && m_source_node == x.m_source_node);
}

bool NodeControl::operator !=(
        const NodeControl& x) const
{
    return !(*this == x);
}

size_t NodeControl::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t NodeControl::getCdrSerializedSize(
        const NodeControl& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.target_node().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.source_node().size() + 1;


    return current_alignment - initial_alignment;
}

void NodeControl::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_cmd_node;
    scdr << (uint32_t)m_cmd_task;
    scdr << m_target_node.c_str();
    scdr << m_task_id;
    scdr << m_source_node.c_str();

}

void NodeControl::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_cmd_node = (CmdNode)enum_value;
    }

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_cmd_task = (CmdTask)enum_value;
    }

    dcdr >> m_target_node;
    dcdr >> m_task_id;
    dcdr >> m_source_node;
}

/*!
 * @brief This function sets a value in member cmd_node
 * @param _cmd_node New value for member cmd_node
 */
void NodeControl::cmd_node(
        CmdNode _cmd_node)
{
    m_cmd_node = _cmd_node;
}

/*!
 * @brief This function returns the value of member cmd_node
 * @return Value of member cmd_node
 */
CmdNode NodeControl::cmd_node() const
{
    return m_cmd_node;
}

/*!
 * @brief This function returns a reference to member cmd_node
 * @return Reference to member cmd_node
 */
CmdNode& NodeControl::cmd_node()
{
    return m_cmd_node;
}

/*!
 * @brief This function sets a value in member cmd_task
 * @param _cmd_task New value for member cmd_task
 */
void NodeControl::cmd_task(
        CmdTask _cmd_task)
{
    m_cmd_task = _cmd_task;
}

/*!
 * @brief This function returns the value of member cmd_task
 * @return Value of member cmd_task
 */
CmdTask NodeControl::cmd_task() const
{
    return m_cmd_task;
}

/*!
 * @brief This function returns a reference to member cmd_task
 * @return Reference to member cmd_task
 */
CmdTask& NodeControl::cmd_task()
{
    return m_cmd_task;
}

/*!
 * @brief This function copies the value in member target_node
 * @param _target_node New value to be copied in member target_node
 */
void NodeControl::target_node(
        const std::string& _target_node)
{
    m_target_node = _target_node;
}

/*!
 * @brief This function moves the value in member target_node
 * @param _target_node New value to be moved in member target_node
 */
void NodeControl::target_node(
        std::string&& _target_node)
{
    m_target_node = std::move(_target_node);
}

/*!
 * @brief This function returns a constant reference to member target_node
 * @return Constant reference to member target_node
 */
const std::string& NodeControl::target_node() const
{
    return m_target_node;
}

/*!
 * @brief This function returns a reference to member target_node
 * @return Reference to member target_node
 */
std::string& NodeControl::target_node()
{
    return m_target_node;
}
/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void NodeControl::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t NodeControl::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& NodeControl::task_id()
{
    return m_task_id;
}

/*!
 * @brief This function copies the value in member source_node
 * @param _source_node New value to be copied in member source_node
 */
void NodeControl::source_node(
        const std::string& _source_node)
{
    m_source_node = _source_node;
}

/*!
 * @brief This function moves the value in member source_node
 * @param _source_node New value to be moved in member source_node
 */
void NodeControl::source_node(
        std::string&& _source_node)
{
    m_source_node = std::move(_source_node);
}

/*!
 * @brief This function returns a constant reference to member source_node
 * @return Constant reference to member source_node
 */
const std::string& NodeControl::source_node() const
{
    return m_source_node;
}

/*!
 * @brief This function returns a reference to member source_node
 * @return Reference to member source_node
 */
std::string& NodeControl::source_node()
{
    return m_source_node;
}

size_t NodeControl::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4) + 255 + 1;
     

    return current_align;
}

bool NodeControl::isKeyDefined()
{
    return true;
}

void NodeControl::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
         scdr << m_source_node.c_str();
      
}

GeoLocation::GeoLocation()
{
    // m_continent com.eprosima.idl.parser.typecode.StringTypeCode@4df828d7
    m_continent ="";
    // m_region com.eprosima.idl.parser.typecode.StringTypeCode@b59d31
    m_region ="";

}

GeoLocation::~GeoLocation()
{


}

GeoLocation::GeoLocation(
        const GeoLocation& x)
{
    m_continent = x.m_continent;
    m_region = x.m_region;
}

GeoLocation::GeoLocation(
        GeoLocation&& x)
{
    m_continent = std::move(x.m_continent);
    m_region = std::move(x.m_region);
}

GeoLocation& GeoLocation::operator =(
        const GeoLocation& x)
{

    m_continent = x.m_continent;
    m_region = x.m_region;

    return *this;
}

GeoLocation& GeoLocation::operator =(
        GeoLocation&& x)
{

    m_continent = std::move(x.m_continent);
    m_region = std::move(x.m_region);

    return *this;
}

bool GeoLocation::operator ==(
        const GeoLocation& x) const
{

    return (m_continent == x.m_continent && m_region == x.m_region);
}

bool GeoLocation::operator !=(
        const GeoLocation& x) const
{
    return !(*this == x);
}

size_t GeoLocation::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t GeoLocation::getCdrSerializedSize(
        const GeoLocation& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.continent().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.region().size() + 1;


    return current_alignment - initial_alignment;
}

void GeoLocation::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_continent.c_str();
    scdr << m_region.c_str();

}

void GeoLocation::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_continent;
    dcdr >> m_region;
}

/*!
 * @brief This function copies the value in member continent
 * @param _continent New value to be copied in member continent
 */
void GeoLocation::continent(
        const std::string& _continent)
{
    m_continent = _continent;
}

/*!
 * @brief This function moves the value in member continent
 * @param _continent New value to be moved in member continent
 */
void GeoLocation::continent(
        std::string&& _continent)
{
    m_continent = std::move(_continent);
}

/*!
 * @brief This function returns a constant reference to member continent
 * @return Constant reference to member continent
 */
const std::string& GeoLocation::continent() const
{
    return m_continent;
}

/*!
 * @brief This function returns a reference to member continent
 * @return Reference to member continent
 */
std::string& GeoLocation::continent()
{
    return m_continent;
}
/*!
 * @brief This function copies the value in member region
 * @param _region New value to be copied in member region
 */
void GeoLocation::region(
        const std::string& _region)
{
    m_region = _region;
}

/*!
 * @brief This function moves the value in member region
 * @param _region New value to be moved in member region
 */
void GeoLocation::region(
        std::string&& _region)
{
    m_region = std::move(_region);
}

/*!
 * @brief This function returns a constant reference to member region
 * @return Constant reference to member region
 */
const std::string& GeoLocation::region() const
{
    return m_region;
}

/*!
 * @brief This function returns a reference to member region
 * @return Reference to member region
 */
std::string& GeoLocation::region()
{
    return m_region;
}

size_t GeoLocation::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool GeoLocation::isKeyDefined()
{
    return false;
}

void GeoLocation::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

UserInput::UserInput()
{
    // m_problem_description com.eprosima.idl.parser.typecode.StringTypeCode@120d6fe6
    m_problem_description ="";
    // m_geo_location com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4ba2ca36

    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6a79c292
    m_task_id = 0;

}

UserInput::~UserInput()
{



}

UserInput::UserInput(
        const UserInput& x)
{
    m_problem_description = x.m_problem_description;
    m_geo_location = x.m_geo_location;
    m_task_id = x.m_task_id;
}

UserInput::UserInput(
        UserInput&& x)
{
    m_problem_description = std::move(x.m_problem_description);
    m_geo_location = std::move(x.m_geo_location);
    m_task_id = x.m_task_id;
}

UserInput& UserInput::operator =(
        const UserInput& x)
{

    m_problem_description = x.m_problem_description;
    m_geo_location = x.m_geo_location;
    m_task_id = x.m_task_id;

    return *this;
}

UserInput& UserInput::operator =(
        UserInput&& x)
{

    m_problem_description = std::move(x.m_problem_description);
    m_geo_location = std::move(x.m_geo_location);
    m_task_id = x.m_task_id;

    return *this;
}

bool UserInput::operator ==(
        const UserInput& x) const
{

    return (m_problem_description == x.m_problem_description && m_geo_location == x.m_geo_location && m_task_id == x.m_task_id);
}

bool UserInput::operator !=(
        const UserInput& x) const
{
    return !(*this == x);
}

size_t UserInput::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += GeoLocation::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t UserInput::getCdrSerializedSize(
        const UserInput& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.problem_description().size() + 1;

    current_alignment += GeoLocation::getCdrSerializedSize(data.geo_location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void UserInput::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_problem_description.c_str();
    scdr << m_geo_location;
    scdr << m_task_id;

}

void UserInput::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_problem_description;
    dcdr >> m_geo_location;
    dcdr >> m_task_id;
}

/*!
 * @brief This function copies the value in member problem_description
 * @param _problem_description New value to be copied in member problem_description
 */
void UserInput::problem_description(
        const std::string& _problem_description)
{
    m_problem_description = _problem_description;
}

/*!
 * @brief This function moves the value in member problem_description
 * @param _problem_description New value to be moved in member problem_description
 */
void UserInput::problem_description(
        std::string&& _problem_description)
{
    m_problem_description = std::move(_problem_description);
}

/*!
 * @brief This function returns a constant reference to member problem_description
 * @return Constant reference to member problem_description
 */
const std::string& UserInput::problem_description() const
{
    return m_problem_description;
}

/*!
 * @brief This function returns a reference to member problem_description
 * @return Reference to member problem_description
 */
std::string& UserInput::problem_description()
{
    return m_problem_description;
}
/*!
 * @brief This function copies the value in member geo_location
 * @param _geo_location New value to be copied in member geo_location
 */
void UserInput::geo_location(
        const GeoLocation& _geo_location)
{
    m_geo_location = _geo_location;
}

/*!
 * @brief This function moves the value in member geo_location
 * @param _geo_location New value to be moved in member geo_location
 */
void UserInput::geo_location(
        GeoLocation&& _geo_location)
{
    m_geo_location = std::move(_geo_location);
}

/*!
 * @brief This function returns a constant reference to member geo_location
 * @return Constant reference to member geo_location
 */
const GeoLocation& UserInput::geo_location() const
{
    return m_geo_location;
}

/*!
 * @brief This function returns a reference to member geo_location
 * @return Reference to member geo_location
 */
GeoLocation& UserInput::geo_location()
{
    return m_geo_location;
}
/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void UserInput::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t UserInput::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& UserInput::task_id()
{
    return m_task_id;
}


size_t UserInput::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;




     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

     

    return current_align;
}

bool UserInput::isKeyDefined()
{
    return true;
}

void UserInput::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       scdr << m_task_id;
      
}

EncodedTask::EncodedTask()
{
    // m_keywords com.eprosima.idl.parser.typecode.SequenceTypeCode@4450d156

    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4461c7e3
    m_task_id = 0;

}

EncodedTask::~EncodedTask()
{


}

EncodedTask::EncodedTask(
        const EncodedTask& x)
{
    m_keywords = x.m_keywords;
    m_task_id = x.m_task_id;
}

EncodedTask::EncodedTask(
        EncodedTask&& x)
{
    m_keywords = std::move(x.m_keywords);
    m_task_id = x.m_task_id;
}

EncodedTask& EncodedTask::operator =(
        const EncodedTask& x)
{

    m_keywords = x.m_keywords;
    m_task_id = x.m_task_id;

    return *this;
}

EncodedTask& EncodedTask::operator =(
        EncodedTask&& x)
{

    m_keywords = std::move(x.m_keywords);
    m_task_id = x.m_task_id;

    return *this;
}

bool EncodedTask::operator ==(
        const EncodedTask& x) const
{

    return (m_keywords == x.m_keywords && m_task_id == x.m_task_id);
}

bool EncodedTask::operator !=(
        const EncodedTask& x) const
{
    return !(*this == x);
}

size_t EncodedTask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t EncodedTask::getCdrSerializedSize(
        const EncodedTask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.keywords().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
            data.keywords().at(a).size() + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void EncodedTask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_keywords;
    scdr << m_task_id;

}

void EncodedTask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_keywords;
    dcdr >> m_task_id;
}

/*!
 * @brief This function copies the value in member keywords
 * @param _keywords New value to be copied in member keywords
 */
void EncodedTask::keywords(
        const std::vector<std::string>& _keywords)
{
    m_keywords = _keywords;
}

/*!
 * @brief This function moves the value in member keywords
 * @param _keywords New value to be moved in member keywords
 */
void EncodedTask::keywords(
        std::vector<std::string>&& _keywords)
{
    m_keywords = std::move(_keywords);
}

/*!
 * @brief This function returns a constant reference to member keywords
 * @return Constant reference to member keywords
 */
const std::vector<std::string>& EncodedTask::keywords() const
{
    return m_keywords;
}

/*!
 * @brief This function returns a reference to member keywords
 * @return Reference to member keywords
 */
std::vector<std::string>& EncodedTask::keywords()
{
    return m_keywords;
}
/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void EncodedTask::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t EncodedTask::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& EncodedTask::task_id()
{
    return m_task_id;
}


size_t EncodedTask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

     

    return current_align;
}

bool EncodedTask::isKeyDefined()
{
    return true;
}

void EncodedTask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      scdr << m_task_id;
      
}

MLModel::MLModel()
{
    // m_model_path com.eprosima.idl.parser.typecode.StringTypeCode@1b68b9a4
    m_model_path ="";
    // m_model com.eprosima.idl.parser.typecode.StringTypeCode@4f9a3314
    m_model ="";
    // m_model_properties_path com.eprosima.idl.parser.typecode.StringTypeCode@3b2c72c2
    m_model_properties_path ="";
    // m_model_properties com.eprosima.idl.parser.typecode.StringTypeCode@491666ad
    m_model_properties ="";
    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@176d53b2
    m_task_id = 0;

}

MLModel::~MLModel()
{





}

MLModel::MLModel(
        const MLModel& x)
{
    m_model_path = x.m_model_path;
    m_model = x.m_model;
    m_model_properties_path = x.m_model_properties_path;
    m_model_properties = x.m_model_properties;
    m_task_id = x.m_task_id;
}

MLModel::MLModel(
        MLModel&& x)
{
    m_model_path = std::move(x.m_model_path);
    m_model = std::move(x.m_model);
    m_model_properties_path = std::move(x.m_model_properties_path);
    m_model_properties = std::move(x.m_model_properties);
    m_task_id = x.m_task_id;
}

MLModel& MLModel::operator =(
        const MLModel& x)
{

    m_model_path = x.m_model_path;
    m_model = x.m_model;
    m_model_properties_path = x.m_model_properties_path;
    m_model_properties = x.m_model_properties;
    m_task_id = x.m_task_id;

    return *this;
}

MLModel& MLModel::operator =(
        MLModel&& x)
{

    m_model_path = std::move(x.m_model_path);
    m_model = std::move(x.m_model);
    m_model_properties_path = std::move(x.m_model_properties_path);
    m_model_properties = std::move(x.m_model_properties);
    m_task_id = x.m_task_id;

    return *this;
}

bool MLModel::operator ==(
        const MLModel& x) const
{

    return (m_model_path == x.m_model_path && m_model == x.m_model && m_model_properties_path == x.m_model_properties_path && m_model_properties == x.m_model_properties && m_task_id == x.m_task_id);
}

bool MLModel::operator !=(
        const MLModel& x) const
{
    return !(*this == x);
}

size_t MLModel::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t MLModel::getCdrSerializedSize(
        const MLModel& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model_path().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model_properties_path().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model_properties().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void MLModel::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_model_path.c_str();
    scdr << m_model.c_str();
    scdr << m_model_properties_path.c_str();
    scdr << m_model_properties.c_str();
    scdr << m_task_id;

}

void MLModel::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_model_path;
    dcdr >> m_model;
    dcdr >> m_model_properties_path;
    dcdr >> m_model_properties;
    dcdr >> m_task_id;
}

/*!
 * @brief This function copies the value in member model_path
 * @param _model_path New value to be copied in member model_path
 */
void MLModel::model_path(
        const std::string& _model_path)
{
    m_model_path = _model_path;
}

/*!
 * @brief This function moves the value in member model_path
 * @param _model_path New value to be moved in member model_path
 */
void MLModel::model_path(
        std::string&& _model_path)
{
    m_model_path = std::move(_model_path);
}

/*!
 * @brief This function returns a constant reference to member model_path
 * @return Constant reference to member model_path
 */
const std::string& MLModel::model_path() const
{
    return m_model_path;
}

/*!
 * @brief This function returns a reference to member model_path
 * @return Reference to member model_path
 */
std::string& MLModel::model_path()
{
    return m_model_path;
}
/*!
 * @brief This function copies the value in member model
 * @param _model New value to be copied in member model
 */
void MLModel::model(
        const std::string& _model)
{
    m_model = _model;
}

/*!
 * @brief This function moves the value in member model
 * @param _model New value to be moved in member model
 */
void MLModel::model(
        std::string&& _model)
{
    m_model = std::move(_model);
}

/*!
 * @brief This function returns a constant reference to member model
 * @return Constant reference to member model
 */
const std::string& MLModel::model() const
{
    return m_model;
}

/*!
 * @brief This function returns a reference to member model
 * @return Reference to member model
 */
std::string& MLModel::model()
{
    return m_model;
}
/*!
 * @brief This function copies the value in member model_properties_path
 * @param _model_properties_path New value to be copied in member model_properties_path
 */
void MLModel::model_properties_path(
        const std::string& _model_properties_path)
{
    m_model_properties_path = _model_properties_path;
}

/*!
 * @brief This function moves the value in member model_properties_path
 * @param _model_properties_path New value to be moved in member model_properties_path
 */
void MLModel::model_properties_path(
        std::string&& _model_properties_path)
{
    m_model_properties_path = std::move(_model_properties_path);
}

/*!
 * @brief This function returns a constant reference to member model_properties_path
 * @return Constant reference to member model_properties_path
 */
const std::string& MLModel::model_properties_path() const
{
    return m_model_properties_path;
}

/*!
 * @brief This function returns a reference to member model_properties_path
 * @return Reference to member model_properties_path
 */
std::string& MLModel::model_properties_path()
{
    return m_model_properties_path;
}
/*!
 * @brief This function copies the value in member model_properties
 * @param _model_properties New value to be copied in member model_properties
 */
void MLModel::model_properties(
        const std::string& _model_properties)
{
    m_model_properties = _model_properties;
}

/*!
 * @brief This function moves the value in member model_properties
 * @param _model_properties New value to be moved in member model_properties
 */
void MLModel::model_properties(
        std::string&& _model_properties)
{
    m_model_properties = std::move(_model_properties);
}

/*!
 * @brief This function returns a constant reference to member model_properties
 * @return Constant reference to member model_properties
 */
const std::string& MLModel::model_properties() const
{
    return m_model_properties;
}

/*!
 * @brief This function returns a reference to member model_properties
 * @return Reference to member model_properties
 */
std::string& MLModel::model_properties()
{
    return m_model_properties;
}
/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void MLModel::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t MLModel::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& MLModel::task_id()
{
    return m_task_id;
}


size_t MLModel::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

     

    return current_align;
}

bool MLModel::isKeyDefined()
{
    return true;
}

void MLModel::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
         scdr << m_task_id;
      
}

HWResource::HWResource()
{
    // m_hw_description com.eprosima.idl.parser.typecode.StringTypeCode@51931956
    m_hw_description ="";
    // m_power_consumption com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2b4a2ec7
    m_power_consumption = 0.0;
    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@564718df
    m_task_id = 0;

}

HWResource::~HWResource()
{



}

HWResource::HWResource(
        const HWResource& x)
{
    m_hw_description = x.m_hw_description;
    m_power_consumption = x.m_power_consumption;
    m_task_id = x.m_task_id;
}

HWResource::HWResource(
        HWResource&& x)
{
    m_hw_description = std::move(x.m_hw_description);
    m_power_consumption = x.m_power_consumption;
    m_task_id = x.m_task_id;
}

HWResource& HWResource::operator =(
        const HWResource& x)
{

    m_hw_description = x.m_hw_description;
    m_power_consumption = x.m_power_consumption;
    m_task_id = x.m_task_id;

    return *this;
}

HWResource& HWResource::operator =(
        HWResource&& x)
{

    m_hw_description = std::move(x.m_hw_description);
    m_power_consumption = x.m_power_consumption;
    m_task_id = x.m_task_id;

    return *this;
}

bool HWResource::operator ==(
        const HWResource& x) const
{

    return (m_hw_description == x.m_hw_description && m_power_consumption == x.m_power_consumption && m_task_id == x.m_task_id);
}

bool HWResource::operator !=(
        const HWResource& x) const
{
    return !(*this == x);
}

size_t HWResource::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t HWResource::getCdrSerializedSize(
        const HWResource& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.hw_description().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void HWResource::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_hw_description.c_str();
    scdr << m_power_consumption;
    scdr << m_task_id;

}

void HWResource::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_hw_description;
    dcdr >> m_power_consumption;
    dcdr >> m_task_id;
}

/*!
 * @brief This function copies the value in member hw_description
 * @param _hw_description New value to be copied in member hw_description
 */
void HWResource::hw_description(
        const std::string& _hw_description)
{
    m_hw_description = _hw_description;
}

/*!
 * @brief This function moves the value in member hw_description
 * @param _hw_description New value to be moved in member hw_description
 */
void HWResource::hw_description(
        std::string&& _hw_description)
{
    m_hw_description = std::move(_hw_description);
}

/*!
 * @brief This function returns a constant reference to member hw_description
 * @return Constant reference to member hw_description
 */
const std::string& HWResource::hw_description() const
{
    return m_hw_description;
}

/*!
 * @brief This function returns a reference to member hw_description
 * @return Reference to member hw_description
 */
std::string& HWResource::hw_description()
{
    return m_hw_description;
}
/*!
 * @brief This function sets a value in member power_consumption
 * @param _power_consumption New value for member power_consumption
 */
void HWResource::power_consumption(
        double _power_consumption)
{
    m_power_consumption = _power_consumption;
}

/*!
 * @brief This function returns the value of member power_consumption
 * @return Value of member power_consumption
 */
double HWResource::power_consumption() const
{
    return m_power_consumption;
}

/*!
 * @brief This function returns a reference to member power_consumption
 * @return Reference to member power_consumption
 */
double& HWResource::power_consumption()
{
    return m_power_consumption;
}

/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void HWResource::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t HWResource::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& HWResource::task_id()
{
    return m_task_id;
}


size_t HWResource::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;




     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

     

    return current_align;
}

bool HWResource::isKeyDefined()
{
    return true;
}

void HWResource::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       scdr << m_task_id;
      
}

CO2Footprint::CO2Footprint()
{
    // m_co2_footprint com.eprosima.idl.parser.typecode.PrimitiveTypeCode@62e136d3
    m_co2_footprint = 0.0;
    // m_energy_consumption com.eprosima.idl.parser.typecode.PrimitiveTypeCode@c8e4bb0
    m_energy_consumption = 0.0;
    // m_carbon_intensity com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6279cee3
    m_carbon_intensity = 0.0;
    // m_task_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4206a205
    m_task_id = 0;

}

CO2Footprint::~CO2Footprint()
{




}

CO2Footprint::CO2Footprint(
        const CO2Footprint& x)
{
    m_co2_footprint = x.m_co2_footprint;
    m_energy_consumption = x.m_energy_consumption;
    m_carbon_intensity = x.m_carbon_intensity;
    m_task_id = x.m_task_id;
}

CO2Footprint::CO2Footprint(
        CO2Footprint&& x)
{
    m_co2_footprint = x.m_co2_footprint;
    m_energy_consumption = x.m_energy_consumption;
    m_carbon_intensity = x.m_carbon_intensity;
    m_task_id = x.m_task_id;
}

CO2Footprint& CO2Footprint::operator =(
        const CO2Footprint& x)
{

    m_co2_footprint = x.m_co2_footprint;
    m_energy_consumption = x.m_energy_consumption;
    m_carbon_intensity = x.m_carbon_intensity;
    m_task_id = x.m_task_id;

    return *this;
}

CO2Footprint& CO2Footprint::operator =(
        CO2Footprint&& x)
{

    m_co2_footprint = x.m_co2_footprint;
    m_energy_consumption = x.m_energy_consumption;
    m_carbon_intensity = x.m_carbon_intensity;
    m_task_id = x.m_task_id;

    return *this;
}

bool CO2Footprint::operator ==(
        const CO2Footprint& x) const
{

    return (m_co2_footprint == x.m_co2_footprint && m_energy_consumption == x.m_energy_consumption && m_carbon_intensity == x.m_carbon_intensity && m_task_id == x.m_task_id);
}

bool CO2Footprint::operator !=(
        const CO2Footprint& x) const
{
    return !(*this == x);
}

size_t CO2Footprint::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t CO2Footprint::getCdrSerializedSize(
        const CO2Footprint& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void CO2Footprint::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_co2_footprint;
    scdr << m_energy_consumption;
    scdr << m_carbon_intensity;
    scdr << m_task_id;

}

void CO2Footprint::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_co2_footprint;
    dcdr >> m_energy_consumption;
    dcdr >> m_carbon_intensity;
    dcdr >> m_task_id;
}

/*!
 * @brief This function sets a value in member co2_footprint
 * @param _co2_footprint New value for member co2_footprint
 */
void CO2Footprint::co2_footprint(
        double _co2_footprint)
{
    m_co2_footprint = _co2_footprint;
}

/*!
 * @brief This function returns the value of member co2_footprint
 * @return Value of member co2_footprint
 */
double CO2Footprint::co2_footprint() const
{
    return m_co2_footprint;
}

/*!
 * @brief This function returns a reference to member co2_footprint
 * @return Reference to member co2_footprint
 */
double& CO2Footprint::co2_footprint()
{
    return m_co2_footprint;
}

/*!
 * @brief This function sets a value in member energy_consumption
 * @param _energy_consumption New value for member energy_consumption
 */
void CO2Footprint::energy_consumption(
        double _energy_consumption)
{
    m_energy_consumption = _energy_consumption;
}

/*!
 * @brief This function returns the value of member energy_consumption
 * @return Value of member energy_consumption
 */
double CO2Footprint::energy_consumption() const
{
    return m_energy_consumption;
}

/*!
 * @brief This function returns a reference to member energy_consumption
 * @return Reference to member energy_consumption
 */
double& CO2Footprint::energy_consumption()
{
    return m_energy_consumption;
}

/*!
 * @brief This function sets a value in member carbon_intensity
 * @param _carbon_intensity New value for member carbon_intensity
 */
void CO2Footprint::carbon_intensity(
        double _carbon_intensity)
{
    m_carbon_intensity = _carbon_intensity;
}

/*!
 * @brief This function returns the value of member carbon_intensity
 * @return Value of member carbon_intensity
 */
double CO2Footprint::carbon_intensity() const
{
    return m_carbon_intensity;
}

/*!
 * @brief This function returns a reference to member carbon_intensity
 * @return Reference to member carbon_intensity
 */
double& CO2Footprint::carbon_intensity()
{
    return m_carbon_intensity;
}

/*!
 * @brief This function sets a value in member task_id
 * @param _task_id New value for member task_id
 */
void CO2Footprint::task_id(
        int32_t _task_id)
{
    m_task_id = _task_id;
}

/*!
 * @brief This function returns the value of member task_id
 * @return Value of member task_id
 */
int32_t CO2Footprint::task_id() const
{
    return m_task_id;
}

/*!
 * @brief This function returns a reference to member task_id
 * @return Reference to member task_id
 */
int32_t& CO2Footprint::task_id()
{
    return m_task_id;
}


size_t CO2Footprint::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);

     

    return current_align;
}

bool CO2Footprint::isKeyDefined()
{
    return true;
}

void CO2Footprint::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        scdr << m_task_id;
      
}
