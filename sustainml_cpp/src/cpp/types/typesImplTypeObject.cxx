// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file typesImplTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
} // namespace
#endif // ifdef _WIN32

#include "typesImpl.h"
#include "typesImplTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

using namespace eprosima::fastrtps::rtps;

void registertypesImplTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory* factory = TypeObjectFactory::get_instance();
                factory->add_type_object("Status", GetStatusIdentifier(true),
                GetStatusObject(true));
                factory->add_type_object("Status", GetStatusIdentifier(false),
                GetStatusObject(false));


                factory->add_type_object("TaskStatus", GetTaskStatusIdentifier(true),
                GetTaskStatusObject(true));
                factory->add_type_object("TaskStatus", GetTaskStatusIdentifier(false),
                GetTaskStatusObject(false));


                factory->add_type_object("ErrorCode", GetErrorCodeIdentifier(true),
                GetErrorCodeObject(true));
                factory->add_type_object("ErrorCode", GetErrorCodeIdentifier(false),
                GetErrorCodeObject(false));


                factory->add_type_object("NodeStatusImpl", GetNodeStatusImplIdentifier(true),
                GetNodeStatusImplObject(true));
                factory->add_type_object("NodeStatusImpl", GetNodeStatusImplIdentifier(false),
                GetNodeStatusImplObject(false));


                factory->add_type_object("CmdNode", GetCmdNodeIdentifier(true),
                GetCmdNodeObject(true));
                factory->add_type_object("CmdNode", GetCmdNodeIdentifier(false),
                GetCmdNodeObject(false));


                factory->add_type_object("CmdTask", GetCmdTaskIdentifier(true),
                GetCmdTaskObject(true));
                factory->add_type_object("CmdTask", GetCmdTaskIdentifier(false),
                GetCmdTaskObject(false));


                factory->add_type_object("NodeControlImpl", GetNodeControlImplIdentifier(true),
                GetNodeControlImplObject(true));
                factory->add_type_object("NodeControlImpl", GetNodeControlImplIdentifier(false),
                GetNodeControlImplObject(false));


                factory->add_type_object("GeoLocationImpl", GetGeoLocationImplIdentifier(true),
                GetGeoLocationImplObject(true));
                factory->add_type_object("GeoLocationImpl", GetGeoLocationImplIdentifier(false),
                GetGeoLocationImplObject(false));


                factory->add_type_object("UserInputImpl", GetUserInputImplIdentifier(true),
                GetUserInputImplObject(true));
                factory->add_type_object("UserInputImpl", GetUserInputImplIdentifier(false),
                GetUserInputImplObject(false));


                factory->add_type_object("EncodedTaskImpl", GetEncodedTaskImplIdentifier(true),
                GetEncodedTaskImplObject(true));
                factory->add_type_object("EncodedTaskImpl", GetEncodedTaskImplIdentifier(false),
                GetEncodedTaskImplObject(false));


                factory->add_type_object("MLModelImpl", GetMLModelImplIdentifier(true),
                GetMLModelImplObject(true));
                factory->add_type_object("MLModelImpl", GetMLModelImplIdentifier(false),
                GetMLModelImplObject(false));


                factory->add_type_object("HWResourceImpl", GetHWResourceImplIdentifier(true),
                GetHWResourceImplObject(true));
                factory->add_type_object("HWResourceImpl", GetHWResourceImplIdentifier(false),
                GetHWResourceImplObject(false));


                factory->add_type_object("CO2FootprintImpl", GetCO2FootprintImplIdentifier(true),
                GetCO2FootprintImplObject(true));
                factory->add_type_object("CO2FootprintImpl", GetCO2FootprintImplIdentifier(false),
                GetCO2FootprintImplObject(false));

            });
}

const TypeIdentifier* GetStatusIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Status", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStatusObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Status", complete);
}

const TypeObject* GetStatusObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Status", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStatusObject();
    }
    // else
    return GetMinimalStatusObject();
}

const TypeObject* GetMinimalStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Status", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NODE_INACTIVE;
    mel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_DEFAULT(false);
    mel_NODE_INACTIVE.common().value(value++);
    MD5 NODE_INACTIVE_hash("NODE_INACTIVE");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_INACTIVE.detail().name_hash()[i] = NODE_INACTIVE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_INACTIVE);

    MinimalEnumeratedLiteral mel_NODE_INITIALIZING;
    mel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_DEFAULT(false);
    mel_NODE_INITIALIZING.common().value(value++);
    MD5 NODE_INITIALIZING_hash("NODE_INITIALIZING");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_INITIALIZING.detail().name_hash()[i] = NODE_INITIALIZING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_INITIALIZING);

    MinimalEnumeratedLiteral mel_NODE_IDLE;
    mel_NODE_IDLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_DEFAULT(false);
    mel_NODE_IDLE.common().value(value++);
    MD5 NODE_IDLE_hash("NODE_IDLE");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_IDLE.detail().name_hash()[i] = NODE_IDLE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_IDLE);

    MinimalEnumeratedLiteral mel_NODE_RUNNING;
    mel_NODE_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_DEFAULT(false);
    mel_NODE_RUNNING.common().value(value++);
    MD5 NODE_RUNNING_hash("NODE_RUNNING");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_RUNNING.detail().name_hash()[i] = NODE_RUNNING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_RUNNING);

    MinimalEnumeratedLiteral mel_NODE_ERROR;
    mel_NODE_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_DEFAULT(false);
    mel_NODE_ERROR.common().value(value++);
    MD5 NODE_ERROR_hash("NODE_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_ERROR.detail().name_hash()[i] = NODE_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_ERROR);

    MinimalEnumeratedLiteral mel_NODE_TERMINATING;
    mel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_DEFAULT(false);
    mel_NODE_TERMINATING.common().value(value++);
    MD5 NODE_TERMINATING_hash("NODE_TERMINATING");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_TERMINATING.detail().name_hash()[i] = NODE_TERMINATING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_TERMINATING);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Status", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Status", false);
}

const TypeObject* GetCompleteStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Status", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("Status");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NODE_INACTIVE;
    cel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_DEFAULT(false);
    cel_NODE_INACTIVE.common().value(value++);
    cel_NODE_INACTIVE.detail().name("NODE_INACTIVE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_INACTIVE);

    CompleteEnumeratedLiteral cel_NODE_INITIALIZING;
    cel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_DEFAULT(false);
    cel_NODE_INITIALIZING.common().value(value++);
    cel_NODE_INITIALIZING.detail().name("NODE_INITIALIZING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_INITIALIZING);

    CompleteEnumeratedLiteral cel_NODE_IDLE;
    cel_NODE_IDLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_DEFAULT(false);
    cel_NODE_IDLE.common().value(value++);
    cel_NODE_IDLE.detail().name("NODE_IDLE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_IDLE);

    CompleteEnumeratedLiteral cel_NODE_RUNNING;
    cel_NODE_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_DEFAULT(false);
    cel_NODE_RUNNING.common().value(value++);
    cel_NODE_RUNNING.detail().name("NODE_RUNNING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_RUNNING);

    CompleteEnumeratedLiteral cel_NODE_ERROR;
    cel_NODE_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_DEFAULT(false);
    cel_NODE_ERROR.common().value(value++);
    cel_NODE_ERROR.detail().name("NODE_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_ERROR);

    CompleteEnumeratedLiteral cel_NODE_TERMINATING;
    cel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_DEFAULT(false);
    cel_NODE_TERMINATING.common().value(value++);
    cel_NODE_TERMINATING.detail().name("NODE_TERMINATING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_TERMINATING);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Status", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Status", true);
}

const TypeIdentifier* GetTaskStatusIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TaskStatus", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetTaskStatusObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("TaskStatus", complete);
}

const TypeObject* GetTaskStatusObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskStatus", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteTaskStatusObject();
    }
    // else
    return GetMinimalTaskStatusObject();
}

const TypeObject* GetMinimalTaskStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskStatus", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_TASK_WAITING;
    mel_TASK_WAITING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_DEFAULT(false);
    mel_TASK_WAITING.common().value(value++);
    MD5 TASK_WAITING_hash("TASK_WAITING");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_WAITING.detail().name_hash()[i] = TASK_WAITING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_WAITING);

    MinimalEnumeratedLiteral mel_TASK_RUNNING;
    mel_TASK_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_DEFAULT(false);
    mel_TASK_RUNNING.common().value(value++);
    MD5 TASK_RUNNING_hash("TASK_RUNNING");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_RUNNING.detail().name_hash()[i] = TASK_RUNNING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_RUNNING);

    MinimalEnumeratedLiteral mel_TASK_ERROR;
    mel_TASK_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_DEFAULT(false);
    mel_TASK_ERROR.common().value(value++);
    MD5 TASK_ERROR_hash("TASK_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_ERROR.detail().name_hash()[i] = TASK_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_ERROR);

    MinimalEnumeratedLiteral mel_TASK_SUCCEEDED;
    mel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_DEFAULT(false);
    mel_TASK_SUCCEEDED.common().value(value++);
    MD5 TASK_SUCCEEDED_hash("TASK_SUCCEEDED");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_SUCCEEDED.detail().name_hash()[i] = TASK_SUCCEEDED_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_SUCCEEDED);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("TaskStatus", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("TaskStatus", false);
}

const TypeObject* GetCompleteTaskStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskStatus", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("TaskStatus");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_TASK_WAITING;
    cel_TASK_WAITING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_DEFAULT(false);
    cel_TASK_WAITING.common().value(value++);
    cel_TASK_WAITING.detail().name("TASK_WAITING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_WAITING);

    CompleteEnumeratedLiteral cel_TASK_RUNNING;
    cel_TASK_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_DEFAULT(false);
    cel_TASK_RUNNING.common().value(value++);
    cel_TASK_RUNNING.detail().name("TASK_RUNNING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_RUNNING);

    CompleteEnumeratedLiteral cel_TASK_ERROR;
    cel_TASK_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_DEFAULT(false);
    cel_TASK_ERROR.common().value(value++);
    cel_TASK_ERROR.detail().name("TASK_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_ERROR);

    CompleteEnumeratedLiteral cel_TASK_SUCCEEDED;
    cel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_DEFAULT(false);
    cel_TASK_SUCCEEDED.common().value(value++);
    cel_TASK_SUCCEEDED.detail().name("TASK_SUCCEEDED");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_SUCCEEDED);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("TaskStatus", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("TaskStatus", true);
}

const TypeIdentifier* GetErrorCodeIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ErrorCode", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetErrorCodeObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ErrorCode", complete);
}

const TypeObject* GetErrorCodeObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ErrorCode", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteErrorCodeObject();
    }
    // else
    return GetMinimalErrorCodeObject();
}

const TypeObject* GetMinimalErrorCodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ErrorCode", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NO_ERROR;
    mel_NO_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NO_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_DEFAULT(false);
    mel_NO_ERROR.common().value(value++);
    MD5 NO_ERROR_hash("NO_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_NO_ERROR.detail().name_hash()[i] = NO_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NO_ERROR);

    MinimalEnumeratedLiteral mel_INTERNAL_ERROR;
    mel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_DEFAULT(false);
    mel_INTERNAL_ERROR.common().value(value++);
    MD5 INTERNAL_ERROR_hash("INTERNAL_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_INTERNAL_ERROR.detail().name_hash()[i] = INTERNAL_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INTERNAL_ERROR);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ErrorCode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ErrorCode", false);
}

const TypeObject* GetCompleteErrorCodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ErrorCode", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("ErrorCode");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NO_ERROR;
    cel_NO_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NO_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_DEFAULT(false);
    cel_NO_ERROR.common().value(value++);
    cel_NO_ERROR.detail().name("NO_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NO_ERROR);

    CompleteEnumeratedLiteral cel_INTERNAL_ERROR;
    cel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_DEFAULT(false);
    cel_INTERNAL_ERROR.common().value(value++);
    cel_INTERNAL_ERROR.detail().name("INTERNAL_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INTERNAL_ERROR);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ErrorCode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ErrorCode", true);
}

const TypeIdentifier* GetNodeStatusImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("NodeStatusImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetNodeStatusImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("NodeStatusImpl", complete);
}

const TypeObject* GetNodeStatusImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteNodeStatusImplObject();
    }
    //else
    return GetMinimalNodeStatusImplObject();
}

const TypeObject* GetMinimalNodeStatusImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_node_status;
    mst_node_status.common().member_id(memberId++);
    mst_node_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_node_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_node_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_node_status.common().member_flags().IS_OPTIONAL(false);
    mst_node_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_node_status.common().member_flags().IS_KEY(false);
    mst_node_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_node_status.common().member_type_id(*GetStatusIdentifier(false));

    MD5 node_status_hash("node_status");
    for (int i = 0; i < 4; ++i)
    {
        mst_node_status.detail().name_hash()[i] = node_status_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_node_status);

    MinimalStructMember mst_task_status;
    mst_task_status.common().member_id(memberId++);
    mst_task_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_status.common().member_flags().IS_OPTIONAL(false);
    mst_task_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_status.common().member_flags().IS_KEY(false);
    mst_task_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_status.common().member_type_id(*GetTaskStatusIdentifier(false));

    MD5 task_status_hash("task_status");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_status.detail().name_hash()[i] = task_status_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_status);

    MinimalStructMember mst_error_code;
    mst_error_code.common().member_id(memberId++);
    mst_error_code.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_error_code.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_error_code.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_error_code.common().member_flags().IS_OPTIONAL(false);
    mst_error_code.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_error_code.common().member_flags().IS_KEY(false);
    mst_error_code.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_error_code.common().member_type_id(*GetErrorCodeIdentifier(false));

    MD5 error_code_hash("error_code");
    for (int i = 0; i < 4; ++i)
    {
        mst_error_code.detail().name_hash()[i] = error_code_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_error_code);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);

    MinimalStructMember mst_error_description;
    mst_error_description.common().member_id(memberId++);
    mst_error_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_error_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_error_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_error_description.common().member_flags().IS_OPTIONAL(false);
    mst_error_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_error_description.common().member_flags().IS_KEY(false);
    mst_error_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_error_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 error_description_hash("error_description");
    for (int i = 0; i < 4; ++i)
    {
        mst_error_description.detail().name_hash()[i] = error_description_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_error_description);

    MinimalStructMember mst_node_name;
    mst_node_name.common().member_id(memberId++);
    mst_node_name.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_node_name.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_node_name.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_node_name.common().member_flags().IS_OPTIONAL(false);
    mst_node_name.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_node_name.common().member_flags().IS_KEY(true);
    mst_node_name.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_node_name.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 node_name_hash("node_name");
    for (int i = 0; i < 4; ++i)
    {
        mst_node_name.detail().name_hash()[i] = node_name_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_node_name);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeStatusImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", false);
}

const TypeObject* GetCompleteNodeStatusImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_node_status;
    cst_node_status.common().member_id(memberId++);
    cst_node_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_node_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_node_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_node_status.common().member_flags().IS_OPTIONAL(false);
    cst_node_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_node_status.common().member_flags().IS_KEY(false);
    cst_node_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_node_status.common().member_type_id(*GetStatusIdentifier(true));

    cst_node_status.detail().name("node_status");

    type_object->complete().struct_type().member_seq().emplace_back(cst_node_status);

    CompleteStructMember cst_task_status;
    cst_task_status.common().member_id(memberId++);
    cst_task_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_status.common().member_flags().IS_OPTIONAL(false);
    cst_task_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_status.common().member_flags().IS_KEY(false);
    cst_task_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_status.common().member_type_id(*GetTaskStatusIdentifier(true));

    cst_task_status.detail().name("task_status");

    type_object->complete().struct_type().member_seq().emplace_back(cst_task_status);

    CompleteStructMember cst_error_code;
    cst_error_code.common().member_id(memberId++);
    cst_error_code.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_error_code.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_error_code.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_error_code.common().member_flags().IS_OPTIONAL(false);
    cst_error_code.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_error_code.common().member_flags().IS_KEY(false);
    cst_error_code.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_error_code.common().member_type_id(*GetErrorCodeIdentifier(true));

    cst_error_code.detail().name("error_code");

    type_object->complete().struct_type().member_seq().emplace_back(cst_error_code);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);

    CompleteStructMember cst_error_description;
    cst_error_description.common().member_id(memberId++);
    cst_error_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_error_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_error_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_error_description.common().member_flags().IS_OPTIONAL(false);
    cst_error_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_error_description.common().member_flags().IS_KEY(false);
    cst_error_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_error_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_error_description.detail().name("error_description");

    type_object->complete().struct_type().member_seq().emplace_back(cst_error_description);

    CompleteStructMember cst_node_name;
    cst_node_name.common().member_id(memberId++);
    cst_node_name.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_node_name.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_node_name.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_node_name.common().member_flags().IS_OPTIONAL(false);
    cst_node_name.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_node_name.common().member_flags().IS_KEY(true);
    cst_node_name.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_node_name.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_node_name.detail().name("node_name");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_node_name.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_node_name);


    // Header
    type_object->complete().struct_type().header().detail().type_name("NodeStatusImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeStatusImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", true);
}

const TypeIdentifier* GetCmdNodeIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CmdNode", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCmdNodeObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CmdNode", complete);
}

const TypeObject* GetCmdNodeObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdNode", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCmdNodeObject();
    }
    // else
    return GetMinimalCmdNodeObject();
}

const TypeObject* GetMinimalCmdNodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdNode", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NO_CMD_NODE;
    mel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_DEFAULT(false);
    mel_NO_CMD_NODE.common().value(value++);
    MD5 NO_CMD_NODE_hash("NO_CMD_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_NO_CMD_NODE.detail().name_hash()[i] = NO_CMD_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NO_CMD_NODE);

    MinimalEnumeratedLiteral mel_CMD_START_NODE;
    mel_CMD_START_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_START_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_START_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_START_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_START_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_START_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_START_NODE.common().flags().IS_DEFAULT(false);
    mel_CMD_START_NODE.common().value(value++);
    MD5 CMD_START_NODE_hash("CMD_START_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_START_NODE.detail().name_hash()[i] = CMD_START_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_START_NODE);

    MinimalEnumeratedLiteral mel_CMD_STOP_NODE;
    mel_CMD_STOP_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_STOP_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_STOP_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_STOP_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_STOP_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_STOP_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_STOP_NODE.common().flags().IS_DEFAULT(false);
    mel_CMD_STOP_NODE.common().value(value++);
    MD5 CMD_STOP_NODE_hash("CMD_STOP_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_STOP_NODE.detail().name_hash()[i] = CMD_STOP_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_STOP_NODE);

    MinimalEnumeratedLiteral mel_CMD_RESET_NODE;
    mel_CMD_RESET_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_RESET_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_RESET_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_RESET_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_RESET_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_RESET_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_RESET_NODE.common().flags().IS_DEFAULT(false);
    mel_CMD_RESET_NODE.common().value(value++);
    MD5 CMD_RESET_NODE_hash("CMD_RESET_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_RESET_NODE.detail().name_hash()[i] = CMD_RESET_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_RESET_NODE);

    MinimalEnumeratedLiteral mel_CMD_TERMINATE_NODE;
    mel_CMD_TERMINATE_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_TERMINATE_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_TERMINATE_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_TERMINATE_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_TERMINATE_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_TERMINATE_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_TERMINATE_NODE.common().flags().IS_DEFAULT(false);
    mel_CMD_TERMINATE_NODE.common().value(value++);
    MD5 CMD_TERMINATE_NODE_hash("CMD_TERMINATE_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_TERMINATE_NODE.detail().name_hash()[i] = CMD_TERMINATE_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_TERMINATE_NODE);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdNode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdNode", false);
}

const TypeObject* GetCompleteCmdNodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdNode", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("CmdNode");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NO_CMD_NODE;
    cel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_DEFAULT(false);
    cel_NO_CMD_NODE.common().value(value++);
    cel_NO_CMD_NODE.detail().name("NO_CMD_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NO_CMD_NODE);

    CompleteEnumeratedLiteral cel_CMD_START_NODE;
    cel_CMD_START_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_START_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_START_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_START_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_START_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_START_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_START_NODE.common().flags().IS_DEFAULT(false);
    cel_CMD_START_NODE.common().value(value++);
    cel_CMD_START_NODE.detail().name("CMD_START_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_START_NODE);

    CompleteEnumeratedLiteral cel_CMD_STOP_NODE;
    cel_CMD_STOP_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_STOP_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_STOP_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_STOP_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_STOP_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_STOP_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_STOP_NODE.common().flags().IS_DEFAULT(false);
    cel_CMD_STOP_NODE.common().value(value++);
    cel_CMD_STOP_NODE.detail().name("CMD_STOP_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_STOP_NODE);

    CompleteEnumeratedLiteral cel_CMD_RESET_NODE;
    cel_CMD_RESET_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_RESET_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_RESET_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_RESET_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_RESET_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_RESET_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_RESET_NODE.common().flags().IS_DEFAULT(false);
    cel_CMD_RESET_NODE.common().value(value++);
    cel_CMD_RESET_NODE.detail().name("CMD_RESET_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_RESET_NODE);

    CompleteEnumeratedLiteral cel_CMD_TERMINATE_NODE;
    cel_CMD_TERMINATE_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_TERMINATE_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_TERMINATE_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_TERMINATE_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_TERMINATE_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_TERMINATE_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_TERMINATE_NODE.common().flags().IS_DEFAULT(false);
    cel_CMD_TERMINATE_NODE.common().value(value++);
    cel_CMD_TERMINATE_NODE.detail().name("CMD_TERMINATE_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_TERMINATE_NODE);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdNode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdNode", true);
}

const TypeIdentifier* GetCmdTaskIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CmdTask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCmdTaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CmdTask", complete);
}

const TypeObject* GetCmdTaskObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdTask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCmdTaskObject();
    }
    // else
    return GetMinimalCmdTaskObject();
}

const TypeObject* GetMinimalCmdTaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdTask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NO_CMD_TASK;
    mel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_DEFAULT(false);
    mel_NO_CMD_TASK.common().value(value++);
    MD5 NO_CMD_TASK_hash("NO_CMD_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_NO_CMD_TASK.detail().name_hash()[i] = NO_CMD_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NO_CMD_TASK);

    MinimalEnumeratedLiteral mel_CMD_STOP_TASK;
    mel_CMD_STOP_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_STOP_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_STOP_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_STOP_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_STOP_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_STOP_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_STOP_TASK.common().flags().IS_DEFAULT(false);
    mel_CMD_STOP_TASK.common().value(value++);
    MD5 CMD_STOP_TASK_hash("CMD_STOP_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_STOP_TASK.detail().name_hash()[i] = CMD_STOP_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_STOP_TASK);

    MinimalEnumeratedLiteral mel_CMD_RESET_TASK;
    mel_CMD_RESET_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_RESET_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_RESET_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_RESET_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_RESET_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_RESET_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_RESET_TASK.common().flags().IS_DEFAULT(false);
    mel_CMD_RESET_TASK.common().value(value++);
    MD5 CMD_RESET_TASK_hash("CMD_RESET_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_RESET_TASK.detail().name_hash()[i] = CMD_RESET_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_RESET_TASK);

    MinimalEnumeratedLiteral mel_CMD_PREEMPT_TASK;
    mel_CMD_PREEMPT_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_PREEMPT_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_PREEMPT_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_PREEMPT_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_PREEMPT_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_PREEMPT_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_PREEMPT_TASK.common().flags().IS_DEFAULT(false);
    mel_CMD_PREEMPT_TASK.common().value(value++);
    MD5 CMD_PREEMPT_TASK_hash("CMD_PREEMPT_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_PREEMPT_TASK.detail().name_hash()[i] = CMD_PREEMPT_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_PREEMPT_TASK);

    MinimalEnumeratedLiteral mel_CMD_TERMINATE_TASK;
    mel_CMD_TERMINATE_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_CMD_TERMINATE_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_CMD_TERMINATE_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_CMD_TERMINATE_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_CMD_TERMINATE_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_CMD_TERMINATE_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_CMD_TERMINATE_TASK.common().flags().IS_DEFAULT(false);
    mel_CMD_TERMINATE_TASK.common().value(value++);
    MD5 CMD_TERMINATE_TASK_hash("CMD_TERMINATE_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_CMD_TERMINATE_TASK.detail().name_hash()[i] = CMD_TERMINATE_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_CMD_TERMINATE_TASK);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdTask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdTask", false);
}

const TypeObject* GetCompleteCmdTaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdTask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("CmdTask");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NO_CMD_TASK;
    cel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_DEFAULT(false);
    cel_NO_CMD_TASK.common().value(value++);
    cel_NO_CMD_TASK.detail().name("NO_CMD_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NO_CMD_TASK);

    CompleteEnumeratedLiteral cel_CMD_STOP_TASK;
    cel_CMD_STOP_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_STOP_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_STOP_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_STOP_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_STOP_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_STOP_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_STOP_TASK.common().flags().IS_DEFAULT(false);
    cel_CMD_STOP_TASK.common().value(value++);
    cel_CMD_STOP_TASK.detail().name("CMD_STOP_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_STOP_TASK);

    CompleteEnumeratedLiteral cel_CMD_RESET_TASK;
    cel_CMD_RESET_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_RESET_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_RESET_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_RESET_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_RESET_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_RESET_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_RESET_TASK.common().flags().IS_DEFAULT(false);
    cel_CMD_RESET_TASK.common().value(value++);
    cel_CMD_RESET_TASK.detail().name("CMD_RESET_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_RESET_TASK);

    CompleteEnumeratedLiteral cel_CMD_PREEMPT_TASK;
    cel_CMD_PREEMPT_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_PREEMPT_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_PREEMPT_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_PREEMPT_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_PREEMPT_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_PREEMPT_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_PREEMPT_TASK.common().flags().IS_DEFAULT(false);
    cel_CMD_PREEMPT_TASK.common().value(value++);
    cel_CMD_PREEMPT_TASK.detail().name("CMD_PREEMPT_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_PREEMPT_TASK);

    CompleteEnumeratedLiteral cel_CMD_TERMINATE_TASK;
    cel_CMD_TERMINATE_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_CMD_TERMINATE_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_CMD_TERMINATE_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_CMD_TERMINATE_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_CMD_TERMINATE_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_CMD_TERMINATE_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_CMD_TERMINATE_TASK.common().flags().IS_DEFAULT(false);
    cel_CMD_TERMINATE_TASK.common().value(value++);
    cel_CMD_TERMINATE_TASK.detail().name("CMD_TERMINATE_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_CMD_TERMINATE_TASK);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdTask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdTask", true);
}

const TypeIdentifier* GetNodeControlImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("NodeControlImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetNodeControlImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("NodeControlImpl", complete);
}

const TypeObject* GetNodeControlImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteNodeControlImplObject();
    }
    //else
    return GetMinimalNodeControlImplObject();
}

const TypeObject* GetMinimalNodeControlImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_cmd_node;
    mst_cmd_node.common().member_id(memberId++);
    mst_cmd_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_cmd_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_cmd_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_cmd_node.common().member_flags().IS_OPTIONAL(false);
    mst_cmd_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_cmd_node.common().member_flags().IS_KEY(false);
    mst_cmd_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_cmd_node.common().member_type_id(*GetCmdNodeIdentifier(false));

    MD5 cmd_node_hash("cmd_node");
    for (int i = 0; i < 4; ++i)
    {
        mst_cmd_node.detail().name_hash()[i] = cmd_node_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_cmd_node);

    MinimalStructMember mst_cmd_task;
    mst_cmd_task.common().member_id(memberId++);
    mst_cmd_task.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_cmd_task.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_cmd_task.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_cmd_task.common().member_flags().IS_OPTIONAL(false);
    mst_cmd_task.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_cmd_task.common().member_flags().IS_KEY(false);
    mst_cmd_task.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_cmd_task.common().member_type_id(*GetCmdTaskIdentifier(false));

    MD5 cmd_task_hash("cmd_task");
    for (int i = 0; i < 4; ++i)
    {
        mst_cmd_task.detail().name_hash()[i] = cmd_task_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_cmd_task);

    MinimalStructMember mst_target_node;
    mst_target_node.common().member_id(memberId++);
    mst_target_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_target_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_target_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_target_node.common().member_flags().IS_OPTIONAL(false);
    mst_target_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_target_node.common().member_flags().IS_KEY(false);
    mst_target_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_target_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 target_node_hash("target_node");
    for (int i = 0; i < 4; ++i)
    {
        mst_target_node.detail().name_hash()[i] = target_node_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_target_node);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(false);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);

    MinimalStructMember mst_source_node;
    mst_source_node.common().member_id(memberId++);
    mst_source_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_source_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_source_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_source_node.common().member_flags().IS_OPTIONAL(false);
    mst_source_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_source_node.common().member_flags().IS_KEY(true);
    mst_source_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_source_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 source_node_hash("source_node");
    for (int i = 0; i < 4; ++i)
    {
        mst_source_node.detail().name_hash()[i] = source_node_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_source_node);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeControlImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", false);
}

const TypeObject* GetCompleteNodeControlImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_cmd_node;
    cst_cmd_node.common().member_id(memberId++);
    cst_cmd_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_cmd_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_cmd_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_cmd_node.common().member_flags().IS_OPTIONAL(false);
    cst_cmd_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_cmd_node.common().member_flags().IS_KEY(false);
    cst_cmd_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_cmd_node.common().member_type_id(*GetCmdNodeIdentifier(true));

    cst_cmd_node.detail().name("cmd_node");

    type_object->complete().struct_type().member_seq().emplace_back(cst_cmd_node);

    CompleteStructMember cst_cmd_task;
    cst_cmd_task.common().member_id(memberId++);
    cst_cmd_task.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_cmd_task.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_cmd_task.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_cmd_task.common().member_flags().IS_OPTIONAL(false);
    cst_cmd_task.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_cmd_task.common().member_flags().IS_KEY(false);
    cst_cmd_task.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_cmd_task.common().member_type_id(*GetCmdTaskIdentifier(true));

    cst_cmd_task.detail().name("cmd_task");

    type_object->complete().struct_type().member_seq().emplace_back(cst_cmd_task);

    CompleteStructMember cst_target_node;
    cst_target_node.common().member_id(memberId++);
    cst_target_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_target_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_target_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_target_node.common().member_flags().IS_OPTIONAL(false);
    cst_target_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_target_node.common().member_flags().IS_KEY(false);
    cst_target_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_target_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_target_node.detail().name("target_node");

    type_object->complete().struct_type().member_seq().emplace_back(cst_target_node);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(false);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);

    CompleteStructMember cst_source_node;
    cst_source_node.common().member_id(memberId++);
    cst_source_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_source_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_source_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_source_node.common().member_flags().IS_OPTIONAL(false);
    cst_source_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_source_node.common().member_flags().IS_KEY(true);
    cst_source_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_source_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_source_node.detail().name("source_node");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_source_node.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_source_node);


    // Header
    type_object->complete().struct_type().header().detail().type_name("NodeControlImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeControlImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", true);
}

const TypeIdentifier* GetGeoLocationImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("GeoLocationImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetGeoLocationImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("GeoLocationImpl", complete);
}

const TypeObject* GetGeoLocationImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GeoLocationImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteGeoLocationImplObject();
    }
    //else
    return GetMinimalGeoLocationImplObject();
}

const TypeObject* GetMinimalGeoLocationImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GeoLocationImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_continent;
    mst_continent.common().member_id(memberId++);
    mst_continent.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_continent.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_continent.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_continent.common().member_flags().IS_OPTIONAL(false);
    mst_continent.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_continent.common().member_flags().IS_KEY(false);
    mst_continent.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_continent.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 continent_hash("continent");
    for (int i = 0; i < 4; ++i)
    {
        mst_continent.detail().name_hash()[i] = continent_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_continent);

    MinimalStructMember mst_region;
    mst_region.common().member_id(memberId++);
    mst_region.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_region.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_region.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_region.common().member_flags().IS_OPTIONAL(false);
    mst_region.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_region.common().member_flags().IS_KEY(false);
    mst_region.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_region.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 region_hash("region");
    for (int i = 0; i < 4; ++i)
    {
        mst_region.detail().name_hash()[i] = region_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_region);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("GeoLocationImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("GeoLocationImpl", false);
}

const TypeObject* GetCompleteGeoLocationImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GeoLocationImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_continent;
    cst_continent.common().member_id(memberId++);
    cst_continent.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_continent.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_continent.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_continent.common().member_flags().IS_OPTIONAL(false);
    cst_continent.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_continent.common().member_flags().IS_KEY(false);
    cst_continent.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_continent.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_continent.detail().name("continent");

    type_object->complete().struct_type().member_seq().emplace_back(cst_continent);

    CompleteStructMember cst_region;
    cst_region.common().member_id(memberId++);
    cst_region.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_region.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_region.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_region.common().member_flags().IS_OPTIONAL(false);
    cst_region.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_region.common().member_flags().IS_KEY(false);
    cst_region.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_region.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_region.detail().name("region");

    type_object->complete().struct_type().member_seq().emplace_back(cst_region);


    // Header
    type_object->complete().struct_type().header().detail().type_name("GeoLocationImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("GeoLocationImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("GeoLocationImpl", true);
}

const TypeIdentifier* GetUserInputImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UserInputImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUserInputImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UserInputImpl", complete);
}

const TypeObject* GetUserInputImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUserInputImplObject();
    }
    //else
    return GetMinimalUserInputImplObject();
}

const TypeObject* GetMinimalUserInputImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_problem_description;
    mst_problem_description.common().member_id(memberId++);
    mst_problem_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_problem_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_problem_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_problem_description.common().member_flags().IS_OPTIONAL(false);
    mst_problem_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_problem_description.common().member_flags().IS_KEY(false);
    mst_problem_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_problem_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 problem_description_hash("problem_description");
    for (int i = 0; i < 4; ++i)
    {
        mst_problem_description.detail().name_hash()[i] = problem_description_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_problem_description);

    MinimalStructMember mst_geo_location;
    mst_geo_location.common().member_id(memberId++);
    mst_geo_location.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_geo_location.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_geo_location.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_geo_location.common().member_flags().IS_OPTIONAL(false);
    mst_geo_location.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_geo_location.common().member_flags().IS_KEY(false);
    mst_geo_location.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_geo_location.common().member_type_id(*GetGeoLocationImplIdentifier(false));

    MD5 geo_location_hash("geo_location");
    for (int i = 0; i < 4; ++i)
    {
        mst_geo_location.detail().name_hash()[i] = geo_location_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_geo_location);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UserInputImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", false);
}

const TypeObject* GetCompleteUserInputImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_problem_description;
    cst_problem_description.common().member_id(memberId++);
    cst_problem_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_problem_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_problem_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_problem_description.common().member_flags().IS_OPTIONAL(false);
    cst_problem_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_problem_description.common().member_flags().IS_KEY(false);
    cst_problem_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_problem_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_problem_description.detail().name("problem_description");

    type_object->complete().struct_type().member_seq().emplace_back(cst_problem_description);

    CompleteStructMember cst_geo_location;
    cst_geo_location.common().member_id(memberId++);
    cst_geo_location.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_geo_location.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_geo_location.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_geo_location.common().member_flags().IS_OPTIONAL(false);
    cst_geo_location.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_geo_location.common().member_flags().IS_KEY(false);
    cst_geo_location.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_geo_location.common().member_type_id(*GetGeoLocationImplIdentifier(true));

    cst_geo_location.detail().name("geo_location");

    type_object->complete().struct_type().member_seq().emplace_back(cst_geo_location);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UserInputImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UserInputImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", true);
}

const TypeIdentifier* GetEncodedTaskImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("EncodedTaskImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetEncodedTaskImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("EncodedTaskImpl", complete);
}

const TypeObject* GetEncodedTaskImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EncodedTaskImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteEncodedTaskImplObject();
    }
    //else
    return GetMinimalEncodedTaskImplObject();
}

const TypeObject* GetMinimalEncodedTaskImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EncodedTaskImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_keywords;
    mst_keywords.common().member_id(memberId++);
    mst_keywords.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_keywords.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_keywords.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_keywords.common().member_flags().IS_OPTIONAL(false);
    mst_keywords.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_keywords.common().member_flags().IS_KEY(false);
    mst_keywords.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_keywords.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator
                    ::get_string_type_name(255, false), 100, false));

    MD5 keywords_hash("keywords");
    for (int i = 0; i < 4; ++i)
    {
        mst_keywords.detail().name_hash()[i] = keywords_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_keywords);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("EncodedTaskImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("EncodedTaskImpl", false);
}

const TypeObject* GetCompleteEncodedTaskImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EncodedTaskImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_keywords;
    cst_keywords.common().member_id(memberId++);
    cst_keywords.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_keywords.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_keywords.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_keywords.common().member_flags().IS_OPTIONAL(false);
    cst_keywords.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_keywords.common().member_flags().IS_KEY(false);
    cst_keywords.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_keywords.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator
                    ::get_string_type_name(255, false), 100, true));

    cst_keywords.detail().name("keywords");

    type_object->complete().struct_type().member_seq().emplace_back(cst_keywords);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("EncodedTaskImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("EncodedTaskImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("EncodedTaskImpl", true);
}

const TypeIdentifier* GetMLModelImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier =
            TypeObjectFactory::get_instance()->get_type_identifier("MLModelImpl", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMLModelImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MLModelImpl", complete);
}

const TypeObject* GetMLModelImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMLModelImplObject();
    }
    //else
    return GetMinimalMLModelImplObject();
}

const TypeObject* GetMinimalMLModelImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_model_path;
    mst_model_path.common().member_id(memberId++);
    mst_model_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model_path.common().member_flags().IS_OPTIONAL(false);
    mst_model_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model_path.common().member_flags().IS_KEY(false);
    mst_model_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 model_path_hash("model_path");
    for (int i = 0; i < 4; ++i)
    {
        mst_model_path.detail().name_hash()[i] = model_path_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model_path);

    MinimalStructMember mst_model;
    mst_model.common().member_id(memberId++);
    mst_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model.common().member_flags().IS_OPTIONAL(false);
    mst_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model.common().member_flags().IS_KEY(false);
    mst_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 model_hash("model");
    for (int i = 0; i < 4; ++i)
    {
        mst_model.detail().name_hash()[i] = model_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model);

    MinimalStructMember mst_model_properties_path;
    mst_model_properties_path.common().member_id(memberId++);
    mst_model_properties_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model_properties_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model_properties_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model_properties_path.common().member_flags().IS_OPTIONAL(false);
    mst_model_properties_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model_properties_path.common().member_flags().IS_KEY(false);
    mst_model_properties_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model_properties_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 model_properties_path_hash("model_properties_path");
    for (int i = 0; i < 4; ++i)
    {
        mst_model_properties_path.detail().name_hash()[i] = model_properties_path_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model_properties_path);

    MinimalStructMember mst_model_properties;
    mst_model_properties.common().member_id(memberId++);
    mst_model_properties.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model_properties.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model_properties.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model_properties.common().member_flags().IS_OPTIONAL(false);
    mst_model_properties.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model_properties.common().member_flags().IS_KEY(false);
    mst_model_properties.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model_properties.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 model_properties_hash("model_properties");
    for (int i = 0; i < 4; ++i)
    {
        mst_model_properties.detail().name_hash()[i] = model_properties_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model_properties);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MLModelImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", false);
}

const TypeObject* GetCompleteMLModelImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_model_path;
    cst_model_path.common().member_id(memberId++);
    cst_model_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model_path.common().member_flags().IS_OPTIONAL(false);
    cst_model_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model_path.common().member_flags().IS_KEY(false);
    cst_model_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_model_path.detail().name("model_path");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model_path);

    CompleteStructMember cst_model;
    cst_model.common().member_id(memberId++);
    cst_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model.common().member_flags().IS_OPTIONAL(false);
    cst_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model.common().member_flags().IS_KEY(false);
    cst_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_model.detail().name("model");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model);

    CompleteStructMember cst_model_properties_path;
    cst_model_properties_path.common().member_id(memberId++);
    cst_model_properties_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model_properties_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model_properties_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model_properties_path.common().member_flags().IS_OPTIONAL(false);
    cst_model_properties_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model_properties_path.common().member_flags().IS_KEY(false);
    cst_model_properties_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model_properties_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_model_properties_path.detail().name("model_properties_path");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model_properties_path);

    CompleteStructMember cst_model_properties;
    cst_model_properties.common().member_id(memberId++);
    cst_model_properties.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model_properties.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model_properties.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model_properties.common().member_flags().IS_OPTIONAL(false);
    cst_model_properties.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model_properties.common().member_flags().IS_KEY(false);
    cst_model_properties.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model_properties.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_model_properties.detail().name("model_properties");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model_properties);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MLModelImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MLModelImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", true);
}

const TypeIdentifier* GetHWResourceImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("HWResourceImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetHWResourceImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("HWResourceImpl", complete);
}

const TypeObject* GetHWResourceImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteHWResourceImplObject();
    }
    //else
    return GetMinimalHWResourceImplObject();
}

const TypeObject* GetMinimalHWResourceImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_hw_description;
    mst_hw_description.common().member_id(memberId++);
    mst_hw_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_hw_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_hw_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_hw_description.common().member_flags().IS_OPTIONAL(false);
    mst_hw_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_hw_description.common().member_flags().IS_KEY(false);
    mst_hw_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_hw_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 hw_description_hash("hw_description");
    for (int i = 0; i < 4; ++i)
    {
        mst_hw_description.detail().name_hash()[i] = hw_description_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_hw_description);

    MinimalStructMember mst_power_consumption;
    mst_power_consumption.common().member_id(memberId++);
    mst_power_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_power_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_power_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_power_consumption.common().member_flags().IS_OPTIONAL(false);
    mst_power_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_power_consumption.common().member_flags().IS_KEY(false);
    mst_power_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_power_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 power_consumption_hash("power_consumption");
    for (int i = 0; i < 4; ++i)
    {
        mst_power_consumption.detail().name_hash()[i] = power_consumption_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_power_consumption);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("HWResourceImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", false);
}

const TypeObject* GetCompleteHWResourceImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_hw_description;
    cst_hw_description.common().member_id(memberId++);
    cst_hw_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_hw_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_hw_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_hw_description.common().member_flags().IS_OPTIONAL(false);
    cst_hw_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_hw_description.common().member_flags().IS_KEY(false);
    cst_hw_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_hw_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_hw_description.detail().name("hw_description");

    type_object->complete().struct_type().member_seq().emplace_back(cst_hw_description);

    CompleteStructMember cst_power_consumption;
    cst_power_consumption.common().member_id(memberId++);
    cst_power_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_power_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_power_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_power_consumption.common().member_flags().IS_OPTIONAL(false);
    cst_power_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_power_consumption.common().member_flags().IS_KEY(false);
    cst_power_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_power_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_power_consumption.detail().name("power_consumption");

    type_object->complete().struct_type().member_seq().emplace_back(cst_power_consumption);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("HWResourceImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("HWResourceImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", true);
}

const TypeIdentifier* GetCO2FootprintImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CO2FootprintImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCO2FootprintImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CO2FootprintImpl", complete);
}

const TypeObject* GetCO2FootprintImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCO2FootprintImplObject();
    }
    //else
    return GetMinimalCO2FootprintImplObject();
}

const TypeObject* GetMinimalCO2FootprintImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_co2_footprint;
    mst_co2_footprint.common().member_id(memberId++);
    mst_co2_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_co2_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_co2_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_co2_footprint.common().member_flags().IS_OPTIONAL(false);
    mst_co2_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_co2_footprint.common().member_flags().IS_KEY(false);
    mst_co2_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_co2_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));


    MD5 co2_footprint_hash("co2_footprint");
    for (int i = 0; i < 4; ++i)
    {
        mst_co2_footprint.detail().name_hash()[i] = co2_footprint_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_co2_footprint);

    MinimalStructMember mst_energy_consumption;
    mst_energy_consumption.common().member_id(memberId++);
    mst_energy_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_energy_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_energy_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_energy_consumption.common().member_flags().IS_OPTIONAL(false);
    mst_energy_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_energy_consumption.common().member_flags().IS_KEY(false);
    mst_energy_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_energy_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 energy_consumption_hash("energy_consumption");
    for (int i = 0; i < 4; ++i)
    {
        mst_energy_consumption.detail().name_hash()[i] = energy_consumption_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_energy_consumption);

    MinimalStructMember mst_carbon_intensity;
    mst_carbon_intensity.common().member_id(memberId++);
    mst_carbon_intensity.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_carbon_intensity.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_carbon_intensity.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_carbon_intensity.common().member_flags().IS_OPTIONAL(false);
    mst_carbon_intensity.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_carbon_intensity.common().member_flags().IS_KEY(false);
    mst_carbon_intensity.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_carbon_intensity.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 carbon_intensity_hash("carbon_intensity");
    for (int i = 0; i < 4; ++i)
    {
        mst_carbon_intensity.detail().name_hash()[i] = carbon_intensity_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_carbon_intensity);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CO2FootprintImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", false);
}

const TypeObject* GetCompleteCO2FootprintImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_co2_footprint;
    cst_co2_footprint.common().member_id(memberId++);
    cst_co2_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_co2_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_co2_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_co2_footprint.common().member_flags().IS_OPTIONAL(false);
    cst_co2_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_co2_footprint.common().member_flags().IS_KEY(false);
    cst_co2_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_co2_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));


    cst_co2_footprint.detail().name("co2_footprint");

    type_object->complete().struct_type().member_seq().emplace_back(cst_co2_footprint);

    CompleteStructMember cst_energy_consumption;
    cst_energy_consumption.common().member_id(memberId++);
    cst_energy_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_energy_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_energy_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_energy_consumption.common().member_flags().IS_OPTIONAL(false);
    cst_energy_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_energy_consumption.common().member_flags().IS_KEY(false);
    cst_energy_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_energy_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_energy_consumption.detail().name("energy_consumption");

    type_object->complete().struct_type().member_seq().emplace_back(cst_energy_consumption);

    CompleteStructMember cst_carbon_intensity;
    cst_carbon_intensity.common().member_id(memberId++);
    cst_carbon_intensity.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_carbon_intensity.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_carbon_intensity.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_carbon_intensity.common().member_flags().IS_OPTIONAL(false);
    cst_carbon_intensity.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_carbon_intensity.common().member_flags().IS_KEY(false);
    cst_carbon_intensity.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_carbon_intensity.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_carbon_intensity.detail().name("carbon_intensity");

    type_object->complete().struct_type().member_seq().emplace_back(cst_carbon_intensity);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetKeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("Key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("CO2FootprintImpl");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv2);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        eprosima::fastcdr::CdrVersion::XCDRv2); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CO2FootprintImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", true);
}
