// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file typesImplTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
} // namespace
#endif // ifdef _WIN32

#include "typesImpl.h"
#include "typesImplTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastdds/rtps/common/CdrSerialization.hpp>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>

using namespace eprosima::fastrtps::rtps;

void registertypesImplTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory* factory = TypeObjectFactory::get_instance();
                factory->add_type_object("Status", GetStatusIdentifier(true),
                GetStatusObject(true));
                factory->add_type_object("Status", GetStatusIdentifier(false),
                GetStatusObject(false));


                factory->add_type_object("TaskStatus", GetTaskStatusIdentifier(true),
                GetTaskStatusObject(true));
                factory->add_type_object("TaskStatus", GetTaskStatusIdentifier(false),
                GetTaskStatusObject(false));


                factory->add_type_object("ErrorCode", GetErrorCodeIdentifier(true),
                GetErrorCodeObject(true));
                factory->add_type_object("ErrorCode", GetErrorCodeIdentifier(false),
                GetErrorCodeObject(false));


                factory->add_type_object("TaskIdImpl", GetTaskIdImplIdentifier(true),
                GetTaskIdImplObject(true));
                factory->add_type_object("TaskIdImpl", GetTaskIdImplIdentifier(false),
                GetTaskIdImplObject(false));


                factory->add_type_object("NodeStatusImpl", GetNodeStatusImplIdentifier(true),
                GetNodeStatusImplObject(true));
                factory->add_type_object("NodeStatusImpl", GetNodeStatusImplIdentifier(false),
                GetNodeStatusImplObject(false));


                factory->add_type_object("CmdNode", GetCmdNodeIdentifier(true),
                GetCmdNodeObject(true));
                factory->add_type_object("CmdNode", GetCmdNodeIdentifier(false),
                GetCmdNodeObject(false));


                factory->add_type_object("CmdTask", GetCmdTaskIdentifier(true),
                GetCmdTaskObject(true));
                factory->add_type_object("CmdTask", GetCmdTaskIdentifier(false),
                GetCmdTaskObject(false));


                factory->add_type_object("NodeControlImpl", GetNodeControlImplIdentifier(true),
                GetNodeControlImplObject(true));
                factory->add_type_object("NodeControlImpl", GetNodeControlImplIdentifier(false),
                GetNodeControlImplObject(false));


                factory->add_type_object("UserInputImpl", GetUserInputImplIdentifier(true),
                GetUserInputImplObject(true));
                factory->add_type_object("UserInputImpl", GetUserInputImplIdentifier(false),
                GetUserInputImplObject(false));


                factory->add_type_object("MLModelMetadataImpl", GetMLModelMetadataImplIdentifier(true),
                GetMLModelMetadataImplObject(true));
                factory->add_type_object("MLModelMetadataImpl", GetMLModelMetadataImplIdentifier(false),
                GetMLModelMetadataImplObject(false));


                factory->add_type_object("AppRequirementsImpl", GetAppRequirementsImplIdentifier(true),
                GetAppRequirementsImplObject(true));
                factory->add_type_object("AppRequirementsImpl", GetAppRequirementsImplIdentifier(false),
                GetAppRequirementsImplObject(false));


                factory->add_type_object("HWConstraintsImpl", GetHWConstraintsImplIdentifier(true),
                GetHWConstraintsImplObject(true));
                factory->add_type_object("HWConstraintsImpl", GetHWConstraintsImplIdentifier(false),
                GetHWConstraintsImplObject(false));


                factory->add_type_object("MLModelImpl", GetMLModelImplIdentifier(true),
                GetMLModelImplObject(true));
                factory->add_type_object("MLModelImpl", GetMLModelImplIdentifier(false),
                GetMLModelImplObject(false));


                factory->add_type_object("HWResourceImpl", GetHWResourceImplIdentifier(true),
                GetHWResourceImplObject(true));
                factory->add_type_object("HWResourceImpl", GetHWResourceImplIdentifier(false),
                GetHWResourceImplObject(false));


                factory->add_type_object("CO2FootprintImpl", GetCO2FootprintImplIdentifier(true),
                GetCO2FootprintImplObject(true));
                factory->add_type_object("CO2FootprintImpl", GetCO2FootprintImplIdentifier(false),
                GetCO2FootprintImplObject(false));

            });
}

const TypeIdentifier* GetStatusIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Status", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStatusObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Status", complete);
}

const TypeObject* GetStatusObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Status", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStatusObject();
    }
    // else
    return GetMinimalStatusObject();
}

const TypeObject* GetMinimalStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Status", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NODE_INACTIVE;
    mel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_INACTIVE.common().flags().IS_DEFAULT(false);
    mel_NODE_INACTIVE.common().value(value++);
    MD5 NODE_INACTIVE_hash("NODE_INACTIVE");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_INACTIVE.detail().name_hash()[i] = NODE_INACTIVE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_INACTIVE);

    MinimalEnumeratedLiteral mel_NODE_ERROR;
    mel_NODE_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_ERROR.common().flags().IS_DEFAULT(false);
    mel_NODE_ERROR.common().value(value++);
    MD5 NODE_ERROR_hash("NODE_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_ERROR.detail().name_hash()[i] = NODE_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_ERROR);

    MinimalEnumeratedLiteral mel_NODE_IDLE;
    mel_NODE_IDLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_IDLE.common().flags().IS_DEFAULT(false);
    mel_NODE_IDLE.common().value(value++);
    MD5 NODE_IDLE_hash("NODE_IDLE");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_IDLE.detail().name_hash()[i] = NODE_IDLE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_IDLE);

    MinimalEnumeratedLiteral mel_NODE_INITIALIZING;
    mel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_INITIALIZING.common().flags().IS_DEFAULT(false);
    mel_NODE_INITIALIZING.common().value(value++);
    MD5 NODE_INITIALIZING_hash("NODE_INITIALIZING");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_INITIALIZING.detail().name_hash()[i] = NODE_INITIALIZING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_INITIALIZING);

    MinimalEnumeratedLiteral mel_NODE_RUNNING;
    mel_NODE_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_RUNNING.common().flags().IS_DEFAULT(false);
    mel_NODE_RUNNING.common().value(value++);
    MD5 NODE_RUNNING_hash("NODE_RUNNING");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_RUNNING.detail().name_hash()[i] = NODE_RUNNING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_RUNNING);

    MinimalEnumeratedLiteral mel_NODE_TERMINATING;
    mel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_KEY(false); // Doesn't apply
    mel_NODE_TERMINATING.common().flags().IS_DEFAULT(false);
    mel_NODE_TERMINATING.common().value(value++);
    MD5 NODE_TERMINATING_hash("NODE_TERMINATING");
    for (int i = 0; i < 4; ++i)
    {
        mel_NODE_TERMINATING.detail().name_hash()[i] = NODE_TERMINATING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NODE_TERMINATING);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Status", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Status", false);
}

const TypeObject* GetCompleteStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Status", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("Status");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NODE_INACTIVE;
    cel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_INACTIVE.common().flags().IS_DEFAULT(false);
    cel_NODE_INACTIVE.common().value(value++);
    cel_NODE_INACTIVE.detail().name("NODE_INACTIVE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_INACTIVE);

    CompleteEnumeratedLiteral cel_NODE_ERROR;
    cel_NODE_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_ERROR.common().flags().IS_DEFAULT(false);
    cel_NODE_ERROR.common().value(value++);
    cel_NODE_ERROR.detail().name("NODE_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_ERROR);

    CompleteEnumeratedLiteral cel_NODE_IDLE;
    cel_NODE_IDLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_IDLE.common().flags().IS_DEFAULT(false);
    cel_NODE_IDLE.common().value(value++);
    cel_NODE_IDLE.detail().name("NODE_IDLE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_IDLE);

    CompleteEnumeratedLiteral cel_NODE_INITIALIZING;
    cel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_INITIALIZING.common().flags().IS_DEFAULT(false);
    cel_NODE_INITIALIZING.common().value(value++);
    cel_NODE_INITIALIZING.detail().name("NODE_INITIALIZING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_INITIALIZING);

    CompleteEnumeratedLiteral cel_NODE_RUNNING;
    cel_NODE_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_RUNNING.common().flags().IS_DEFAULT(false);
    cel_NODE_RUNNING.common().value(value++);
    cel_NODE_RUNNING.detail().name("NODE_RUNNING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_RUNNING);

    CompleteEnumeratedLiteral cel_NODE_TERMINATING;
    cel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_KEY(false); // Doesn't apply
    cel_NODE_TERMINATING.common().flags().IS_DEFAULT(false);
    cel_NODE_TERMINATING.common().value(value++);
    cel_NODE_TERMINATING.detail().name("NODE_TERMINATING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NODE_TERMINATING);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Status", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Status", true);
}

const TypeIdentifier* GetTaskStatusIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TaskStatus", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetTaskStatusObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("TaskStatus", complete);
}

const TypeObject* GetTaskStatusObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskStatus", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteTaskStatusObject();
    }
    // else
    return GetMinimalTaskStatusObject();
}

const TypeObject* GetMinimalTaskStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskStatus", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_TASK_WAITING;
    mel_TASK_WAITING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_WAITING.common().flags().IS_DEFAULT(false);
    mel_TASK_WAITING.common().value(value++);
    MD5 TASK_WAITING_hash("TASK_WAITING");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_WAITING.detail().name_hash()[i] = TASK_WAITING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_WAITING);

    MinimalEnumeratedLiteral mel_TASK_ERROR;
    mel_TASK_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_ERROR.common().flags().IS_DEFAULT(false);
    mel_TASK_ERROR.common().value(value++);
    MD5 TASK_ERROR_hash("TASK_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_ERROR.detail().name_hash()[i] = TASK_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_ERROR);

    MinimalEnumeratedLiteral mel_TASK_RUNNING;
    mel_TASK_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_RUNNING.common().flags().IS_DEFAULT(false);
    mel_TASK_RUNNING.common().value(value++);
    MD5 TASK_RUNNING_hash("TASK_RUNNING");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_RUNNING.detail().name_hash()[i] = TASK_RUNNING_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_RUNNING);

    MinimalEnumeratedLiteral mel_TASK_SUCCEEDED;
    mel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_KEY(false); // Doesn't apply
    mel_TASK_SUCCEEDED.common().flags().IS_DEFAULT(false);
    mel_TASK_SUCCEEDED.common().value(value++);
    MD5 TASK_SUCCEEDED_hash("TASK_SUCCEEDED");
    for (int i = 0; i < 4; ++i)
    {
        mel_TASK_SUCCEEDED.detail().name_hash()[i] = TASK_SUCCEEDED_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TASK_SUCCEEDED);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("TaskStatus", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("TaskStatus", false);
}

const TypeObject* GetCompleteTaskStatusObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskStatus", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("TaskStatus");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_TASK_WAITING;
    cel_TASK_WAITING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_WAITING.common().flags().IS_DEFAULT(false);
    cel_TASK_WAITING.common().value(value++);
    cel_TASK_WAITING.detail().name("TASK_WAITING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_WAITING);

    CompleteEnumeratedLiteral cel_TASK_ERROR;
    cel_TASK_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_ERROR.common().flags().IS_DEFAULT(false);
    cel_TASK_ERROR.common().value(value++);
    cel_TASK_ERROR.detail().name("TASK_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_ERROR);

    CompleteEnumeratedLiteral cel_TASK_RUNNING;
    cel_TASK_RUNNING.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_RUNNING.common().flags().IS_DEFAULT(false);
    cel_TASK_RUNNING.common().value(value++);
    cel_TASK_RUNNING.detail().name("TASK_RUNNING");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_RUNNING);

    CompleteEnumeratedLiteral cel_TASK_SUCCEEDED;
    cel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_KEY(false); // Doesn't apply
    cel_TASK_SUCCEEDED.common().flags().IS_DEFAULT(false);
    cel_TASK_SUCCEEDED.common().value(value++);
    cel_TASK_SUCCEEDED.detail().name("TASK_SUCCEEDED");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TASK_SUCCEEDED);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("TaskStatus", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("TaskStatus", true);
}

const TypeIdentifier* GetErrorCodeIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ErrorCode", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetErrorCodeObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ErrorCode", complete);
}

const TypeObject* GetErrorCodeObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ErrorCode", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteErrorCodeObject();
    }
    // else
    return GetMinimalErrorCodeObject();
}

const TypeObject* GetMinimalErrorCodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ErrorCode", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NO_ERROR;
    mel_NO_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NO_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_NO_ERROR.common().flags().IS_DEFAULT(false);
    mel_NO_ERROR.common().value(value++);
    MD5 NO_ERROR_hash("NO_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_NO_ERROR.detail().name_hash()[i] = NO_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NO_ERROR);

    MinimalEnumeratedLiteral mel_INTERNAL_ERROR;
    mel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    mel_INTERNAL_ERROR.common().flags().IS_DEFAULT(false);
    mel_INTERNAL_ERROR.common().value(value++);
    MD5 INTERNAL_ERROR_hash("INTERNAL_ERROR");
    for (int i = 0; i < 4; ++i)
    {
        mel_INTERNAL_ERROR.detail().name_hash()[i] = INTERNAL_ERROR_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INTERNAL_ERROR);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ErrorCode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ErrorCode", false);
}

const TypeObject* GetCompleteErrorCodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ErrorCode", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("ErrorCode");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NO_ERROR;
    cel_NO_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NO_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_NO_ERROR.common().flags().IS_DEFAULT(false);
    cel_NO_ERROR.common().value(value++);
    cel_NO_ERROR.detail().name("NO_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NO_ERROR);

    CompleteEnumeratedLiteral cel_INTERNAL_ERROR;
    cel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_KEY(false); // Doesn't apply
    cel_INTERNAL_ERROR.common().flags().IS_DEFAULT(false);
    cel_INTERNAL_ERROR.common().value(value++);
    cel_INTERNAL_ERROR.detail().name("INTERNAL_ERROR");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INTERNAL_ERROR);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ErrorCode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ErrorCode", true);
}

const TypeIdentifier* GetTaskIdImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TaskIdImpl", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetTaskIdImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("TaskIdImpl", complete);
}

const TypeObject* GetTaskIdImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskIdImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteTaskIdImplObject();
    }
    //else
    return GetMinimalTaskIdImplObject();
}

const TypeObject* GetMinimalTaskIdImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskIdImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_problem_id;
    mst_problem_id.common().member_id(memberId++);
    mst_problem_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_problem_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_problem_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_problem_id.common().member_flags().IS_OPTIONAL(false);
    mst_problem_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_problem_id.common().member_flags().IS_KEY(false);
    mst_problem_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_problem_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


    MD5 problem_id_hash("problem_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_problem_id.detail().name_hash()[i] = problem_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_problem_id);

    MinimalStructMember mst_iteration_id;
    mst_iteration_id.common().member_id(memberId++);
    mst_iteration_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_iteration_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_iteration_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_iteration_id.common().member_flags().IS_OPTIONAL(false);
    mst_iteration_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_iteration_id.common().member_flags().IS_KEY(false);
    mst_iteration_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_iteration_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    MD5 iteration_id_hash("iteration_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_iteration_id.detail().name_hash()[i] = iteration_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_iteration_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("TaskIdImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("TaskIdImpl", false);
}

const TypeObject* GetCompleteTaskIdImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TaskIdImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_problem_id;
    cst_problem_id.common().member_id(memberId++);
    cst_problem_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_problem_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_problem_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_problem_id.common().member_flags().IS_OPTIONAL(false);
    cst_problem_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_problem_id.common().member_flags().IS_KEY(false);
    cst_problem_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_problem_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


    cst_problem_id.detail().name("problem_id");

    type_object->complete().struct_type().member_seq().emplace_back(cst_problem_id);

    CompleteStructMember cst_iteration_id;
    cst_iteration_id.common().member_id(memberId++);
    cst_iteration_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_iteration_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_iteration_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_iteration_id.common().member_flags().IS_OPTIONAL(false);
    cst_iteration_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_iteration_id.common().member_flags().IS_KEY(false);
    cst_iteration_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_iteration_id.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    cst_iteration_id.detail().name("iteration_id");

    type_object->complete().struct_type().member_seq().emplace_back(cst_iteration_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("TaskIdImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("TaskIdImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("TaskIdImpl", true);
}

const TypeIdentifier* GetNodeStatusImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("NodeStatusImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetNodeStatusImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("NodeStatusImpl", complete);
}

const TypeObject* GetNodeStatusImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteNodeStatusImplObject();
    }
    //else
    return GetMinimalNodeStatusImplObject();
}

const TypeObject* GetMinimalNodeStatusImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_node_status;
    mst_node_status.common().member_id(memberId++);
    mst_node_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_node_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_node_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_node_status.common().member_flags().IS_OPTIONAL(false);
    mst_node_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_node_status.common().member_flags().IS_KEY(false);
    mst_node_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_node_status.common().member_type_id(*GetStatusIdentifier(false));

    MD5 node_status_hash("node_status");
    for (int i = 0; i < 4; ++i)
    {
        mst_node_status.detail().name_hash()[i] = node_status_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_node_status);

    MinimalStructMember mst_task_status;
    mst_task_status.common().member_id(memberId++);
    mst_task_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_status.common().member_flags().IS_OPTIONAL(false);
    mst_task_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_status.common().member_flags().IS_KEY(false);
    mst_task_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_status.common().member_type_id(*GetTaskStatusIdentifier(false));

    MD5 task_status_hash("task_status");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_status.detail().name_hash()[i] = task_status_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_status);

    MinimalStructMember mst_error_code;
    mst_error_code.common().member_id(memberId++);
    mst_error_code.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_error_code.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_error_code.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_error_code.common().member_flags().IS_OPTIONAL(false);
    mst_error_code.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_error_code.common().member_flags().IS_KEY(false);
    mst_error_code.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_error_code.common().member_type_id(*GetErrorCodeIdentifier(false));

    MD5 error_code_hash("error_code");
    for (int i = 0; i < 4; ++i)
    {
        mst_error_code.detail().name_hash()[i] = error_code_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_error_code);

    MinimalStructMember mst_error_description;
    mst_error_description.common().member_id(memberId++);
    mst_error_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_error_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_error_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_error_description.common().member_flags().IS_OPTIONAL(false);
    mst_error_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_error_description.common().member_flags().IS_KEY(false);
    mst_error_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_error_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 error_description_hash("error_description");
    for (int i = 0; i < 4; ++i)
    {
        mst_error_description.detail().name_hash()[i] = error_description_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_error_description);

    MinimalStructMember mst_node_name;
    mst_node_name.common().member_id(memberId++);
    mst_node_name.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_node_name.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_node_name.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_node_name.common().member_flags().IS_OPTIONAL(false);
    mst_node_name.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_node_name.common().member_flags().IS_KEY(true);
    mst_node_name.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_node_name.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 node_name_hash("node_name");
    for (int i = 0; i < 4; ++i)
    {
        mst_node_name.detail().name_hash()[i] = node_name_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_node_name);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeStatusImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", false);
}

const TypeObject* GetCompleteNodeStatusImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_node_status;
    cst_node_status.common().member_id(memberId++);
    cst_node_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_node_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_node_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_node_status.common().member_flags().IS_OPTIONAL(false);
    cst_node_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_node_status.common().member_flags().IS_KEY(false);
    cst_node_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_node_status.common().member_type_id(*GetStatusIdentifier(true));

    cst_node_status.detail().name("node_status");

    type_object->complete().struct_type().member_seq().emplace_back(cst_node_status);

    CompleteStructMember cst_task_status;
    cst_task_status.common().member_id(memberId++);
    cst_task_status.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_status.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_status.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_status.common().member_flags().IS_OPTIONAL(false);
    cst_task_status.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_status.common().member_flags().IS_KEY(false);
    cst_task_status.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_status.common().member_type_id(*GetTaskStatusIdentifier(true));

    cst_task_status.detail().name("task_status");

    type_object->complete().struct_type().member_seq().emplace_back(cst_task_status);

    CompleteStructMember cst_error_code;
    cst_error_code.common().member_id(memberId++);
    cst_error_code.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_error_code.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_error_code.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_error_code.common().member_flags().IS_OPTIONAL(false);
    cst_error_code.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_error_code.common().member_flags().IS_KEY(false);
    cst_error_code.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_error_code.common().member_type_id(*GetErrorCodeIdentifier(true));

    cst_error_code.detail().name("error_code");

    type_object->complete().struct_type().member_seq().emplace_back(cst_error_code);

    CompleteStructMember cst_error_description;
    cst_error_description.common().member_id(memberId++);
    cst_error_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_error_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_error_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_error_description.common().member_flags().IS_OPTIONAL(false);
    cst_error_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_error_description.common().member_flags().IS_KEY(false);
    cst_error_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_error_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_error_description.detail().name("error_description");

    type_object->complete().struct_type().member_seq().emplace_back(cst_error_description);

    CompleteStructMember cst_node_name;
    cst_node_name.common().member_id(memberId++);
    cst_node_name.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_node_name.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_node_name.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_node_name.common().member_flags().IS_OPTIONAL(false);
    cst_node_name.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_node_name.common().member_flags().IS_KEY(true);
    cst_node_name.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_node_name.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_node_name.detail().name("node_name");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_node_name.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_node_name);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("NodeStatusImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeStatusImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeStatusImpl", true);
}

const TypeIdentifier* GetCmdNodeIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CmdNode", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCmdNodeObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CmdNode", complete);
}

const TypeObject* GetCmdNodeObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdNode", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCmdNodeObject();
    }
    // else
    return GetMinimalCmdNodeObject();
}

const TypeObject* GetMinimalCmdNodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdNode", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NO_CMD_NODE;
    mel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_NO_CMD_NODE.common().flags().IS_DEFAULT(false);
    mel_NO_CMD_NODE.common().value(value++);
    MD5 NO_CMD_NODE_hash("NO_CMD_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_NO_CMD_NODE.detail().name_hash()[i] = NO_CMD_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NO_CMD_NODE);

    MinimalEnumeratedLiteral mel_START_NODE;
    mel_START_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_START_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_START_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_START_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_START_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_START_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_START_NODE.common().flags().IS_DEFAULT(false);
    mel_START_NODE.common().value(value++);
    MD5 START_NODE_hash("START_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_START_NODE.detail().name_hash()[i] = START_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_START_NODE);

    MinimalEnumeratedLiteral mel_STOP_NODE;
    mel_STOP_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_STOP_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_STOP_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_STOP_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_STOP_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_STOP_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_STOP_NODE.common().flags().IS_DEFAULT(false);
    mel_STOP_NODE.common().value(value++);
    MD5 STOP_NODE_hash("STOP_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_STOP_NODE.detail().name_hash()[i] = STOP_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_STOP_NODE);

    MinimalEnumeratedLiteral mel_RESET_NODE;
    mel_RESET_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_RESET_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_RESET_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_RESET_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_RESET_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_RESET_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_RESET_NODE.common().flags().IS_DEFAULT(false);
    mel_RESET_NODE.common().value(value++);
    MD5 RESET_NODE_hash("RESET_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_RESET_NODE.detail().name_hash()[i] = RESET_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_RESET_NODE);

    MinimalEnumeratedLiteral mel_TERMINATE_NODE;
    mel_TERMINATE_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TERMINATE_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TERMINATE_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TERMINATE_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TERMINATE_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TERMINATE_NODE.common().flags().IS_KEY(false); // Doesn't apply
    mel_TERMINATE_NODE.common().flags().IS_DEFAULT(false);
    mel_TERMINATE_NODE.common().value(value++);
    MD5 TERMINATE_NODE_hash("TERMINATE_NODE");
    for (int i = 0; i < 4; ++i)
    {
        mel_TERMINATE_NODE.detail().name_hash()[i] = TERMINATE_NODE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TERMINATE_NODE);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdNode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdNode", false);
}

const TypeObject* GetCompleteCmdNodeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdNode", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("CmdNode");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NO_CMD_NODE;
    cel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_NO_CMD_NODE.common().flags().IS_DEFAULT(false);
    cel_NO_CMD_NODE.common().value(value++);
    cel_NO_CMD_NODE.detail().name("NO_CMD_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NO_CMD_NODE);

    CompleteEnumeratedLiteral cel_START_NODE;
    cel_START_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_START_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_START_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_START_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_START_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_START_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_START_NODE.common().flags().IS_DEFAULT(false);
    cel_START_NODE.common().value(value++);
    cel_START_NODE.detail().name("START_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_START_NODE);

    CompleteEnumeratedLiteral cel_STOP_NODE;
    cel_STOP_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_STOP_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_STOP_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_STOP_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_STOP_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_STOP_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_STOP_NODE.common().flags().IS_DEFAULT(false);
    cel_STOP_NODE.common().value(value++);
    cel_STOP_NODE.detail().name("STOP_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_STOP_NODE);

    CompleteEnumeratedLiteral cel_RESET_NODE;
    cel_RESET_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_RESET_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_RESET_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_RESET_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_RESET_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_RESET_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_RESET_NODE.common().flags().IS_DEFAULT(false);
    cel_RESET_NODE.common().value(value++);
    cel_RESET_NODE.detail().name("RESET_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_RESET_NODE);

    CompleteEnumeratedLiteral cel_TERMINATE_NODE;
    cel_TERMINATE_NODE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TERMINATE_NODE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TERMINATE_NODE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TERMINATE_NODE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TERMINATE_NODE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TERMINATE_NODE.common().flags().IS_KEY(false); // Doesn't apply
    cel_TERMINATE_NODE.common().flags().IS_DEFAULT(false);
    cel_TERMINATE_NODE.common().value(value++);
    cel_TERMINATE_NODE.detail().name("TERMINATE_NODE");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TERMINATE_NODE);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdNode", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdNode", true);
}

const TypeIdentifier* GetCmdTaskIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CmdTask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCmdTaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CmdTask", complete);
}

const TypeObject* GetCmdTaskObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdTask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCmdTaskObject();
    }
    // else
    return GetMinimalCmdTaskObject();
}

const TypeObject* GetMinimalCmdTaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdTask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_NO_CMD_TASK;
    mel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_NO_CMD_TASK.common().flags().IS_DEFAULT(false);
    mel_NO_CMD_TASK.common().value(value++);
    MD5 NO_CMD_TASK_hash("NO_CMD_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_NO_CMD_TASK.detail().name_hash()[i] = NO_CMD_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NO_CMD_TASK);

    MinimalEnumeratedLiteral mel_STOP_TASK;
    mel_STOP_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_STOP_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_STOP_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_STOP_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_STOP_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_STOP_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_STOP_TASK.common().flags().IS_DEFAULT(false);
    mel_STOP_TASK.common().value(value++);
    MD5 STOP_TASK_hash("STOP_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_STOP_TASK.detail().name_hash()[i] = STOP_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_STOP_TASK);

    MinimalEnumeratedLiteral mel_RESET_TASK;
    mel_RESET_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_RESET_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_RESET_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_RESET_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_RESET_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_RESET_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_RESET_TASK.common().flags().IS_DEFAULT(false);
    mel_RESET_TASK.common().value(value++);
    MD5 RESET_TASK_hash("RESET_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_RESET_TASK.detail().name_hash()[i] = RESET_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_RESET_TASK);

    MinimalEnumeratedLiteral mel_PREEMPT_TASK;
    mel_PREEMPT_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_PREEMPT_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_PREEMPT_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_PREEMPT_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_PREEMPT_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_PREEMPT_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_PREEMPT_TASK.common().flags().IS_DEFAULT(false);
    mel_PREEMPT_TASK.common().value(value++);
    MD5 PREEMPT_TASK_hash("PREEMPT_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_PREEMPT_TASK.detail().name_hash()[i] = PREEMPT_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_PREEMPT_TASK);

    MinimalEnumeratedLiteral mel_TERMINATE_TASK;
    mel_TERMINATE_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_TERMINATE_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_TERMINATE_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_TERMINATE_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_TERMINATE_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_TERMINATE_TASK.common().flags().IS_KEY(false); // Doesn't apply
    mel_TERMINATE_TASK.common().flags().IS_DEFAULT(false);
    mel_TERMINATE_TASK.common().value(value++);
    MD5 TERMINATE_TASK_hash("TERMINATE_TASK");
    for (int i = 0; i < 4; ++i)
    {
        mel_TERMINATE_TASK.detail().name_hash()[i] = TERMINATE_TASK_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_TERMINATE_TASK);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdTask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdTask", false);
}

const TypeObject* GetCompleteCmdTaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CmdTask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("CmdTask");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_NO_CMD_TASK;
    cel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_NO_CMD_TASK.common().flags().IS_DEFAULT(false);
    cel_NO_CMD_TASK.common().value(value++);
    cel_NO_CMD_TASK.detail().name("NO_CMD_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NO_CMD_TASK);

    CompleteEnumeratedLiteral cel_STOP_TASK;
    cel_STOP_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_STOP_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_STOP_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_STOP_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_STOP_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_STOP_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_STOP_TASK.common().flags().IS_DEFAULT(false);
    cel_STOP_TASK.common().value(value++);
    cel_STOP_TASK.detail().name("STOP_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_STOP_TASK);

    CompleteEnumeratedLiteral cel_RESET_TASK;
    cel_RESET_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_RESET_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_RESET_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_RESET_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_RESET_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_RESET_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_RESET_TASK.common().flags().IS_DEFAULT(false);
    cel_RESET_TASK.common().value(value++);
    cel_RESET_TASK.detail().name("RESET_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_RESET_TASK);

    CompleteEnumeratedLiteral cel_PREEMPT_TASK;
    cel_PREEMPT_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_PREEMPT_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_PREEMPT_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_PREEMPT_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_PREEMPT_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_PREEMPT_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_PREEMPT_TASK.common().flags().IS_DEFAULT(false);
    cel_PREEMPT_TASK.common().value(value++);
    cel_PREEMPT_TASK.detail().name("PREEMPT_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_PREEMPT_TASK);

    CompleteEnumeratedLiteral cel_TERMINATE_TASK;
    cel_TERMINATE_TASK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_TERMINATE_TASK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_TERMINATE_TASK.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_TERMINATE_TASK.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_TERMINATE_TASK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_TERMINATE_TASK.common().flags().IS_KEY(false); // Doesn't apply
    cel_TERMINATE_TASK.common().flags().IS_DEFAULT(false);
    cel_TERMINATE_TASK.common().value(value++);
    cel_TERMINATE_TASK.detail().name("TERMINATE_TASK");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_TERMINATE_TASK);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CmdTask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CmdTask", true);
}

const TypeIdentifier* GetNodeControlImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("NodeControlImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetNodeControlImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("NodeControlImpl", complete);
}

const TypeObject* GetNodeControlImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteNodeControlImplObject();
    }
    //else
    return GetMinimalNodeControlImplObject();
}

const TypeObject* GetMinimalNodeControlImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_cmd_node;
    mst_cmd_node.common().member_id(memberId++);
    mst_cmd_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_cmd_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_cmd_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_cmd_node.common().member_flags().IS_OPTIONAL(false);
    mst_cmd_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_cmd_node.common().member_flags().IS_KEY(false);
    mst_cmd_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_cmd_node.common().member_type_id(*GetCmdNodeIdentifier(false));

    MD5 cmd_node_hash("cmd_node");
    for (int i = 0; i < 4; ++i)
    {
        mst_cmd_node.detail().name_hash()[i] = cmd_node_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_cmd_node);

    MinimalStructMember mst_cmd_task;
    mst_cmd_task.common().member_id(memberId++);
    mst_cmd_task.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_cmd_task.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_cmd_task.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_cmd_task.common().member_flags().IS_OPTIONAL(false);
    mst_cmd_task.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_cmd_task.common().member_flags().IS_KEY(false);
    mst_cmd_task.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_cmd_task.common().member_type_id(*GetCmdTaskIdentifier(false));

    MD5 cmd_task_hash("cmd_task");
    for (int i = 0; i < 4; ++i)
    {
        mst_cmd_task.detail().name_hash()[i] = cmd_task_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_cmd_task);

    MinimalStructMember mst_target_node;
    mst_target_node.common().member_id(memberId++);
    mst_target_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_target_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_target_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_target_node.common().member_flags().IS_OPTIONAL(false);
    mst_target_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_target_node.common().member_flags().IS_KEY(false);
    mst_target_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_target_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 target_node_hash("target_node");
    for (int i = 0; i < 4; ++i)
    {
        mst_target_node.detail().name_hash()[i] = target_node_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_target_node);

    MinimalStructMember mst_source_node;
    mst_source_node.common().member_id(memberId++);
    mst_source_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_source_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_source_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_source_node.common().member_flags().IS_OPTIONAL(false);
    mst_source_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_source_node.common().member_flags().IS_KEY(true);
    mst_source_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_source_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 source_node_hash("source_node");
    for (int i = 0; i < 4; ++i)
    {
        mst_source_node.detail().name_hash()[i] = source_node_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_source_node);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeControlImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", false);
}

const TypeObject* GetCompleteNodeControlImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_cmd_node;
    cst_cmd_node.common().member_id(memberId++);
    cst_cmd_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_cmd_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_cmd_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_cmd_node.common().member_flags().IS_OPTIONAL(false);
    cst_cmd_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_cmd_node.common().member_flags().IS_KEY(false);
    cst_cmd_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_cmd_node.common().member_type_id(*GetCmdNodeIdentifier(true));

    cst_cmd_node.detail().name("cmd_node");

    type_object->complete().struct_type().member_seq().emplace_back(cst_cmd_node);

    CompleteStructMember cst_cmd_task;
    cst_cmd_task.common().member_id(memberId++);
    cst_cmd_task.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_cmd_task.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_cmd_task.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_cmd_task.common().member_flags().IS_OPTIONAL(false);
    cst_cmd_task.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_cmd_task.common().member_flags().IS_KEY(false);
    cst_cmd_task.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_cmd_task.common().member_type_id(*GetCmdTaskIdentifier(true));

    cst_cmd_task.detail().name("cmd_task");

    type_object->complete().struct_type().member_seq().emplace_back(cst_cmd_task);

    CompleteStructMember cst_target_node;
    cst_target_node.common().member_id(memberId++);
    cst_target_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_target_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_target_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_target_node.common().member_flags().IS_OPTIONAL(false);
    cst_target_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_target_node.common().member_flags().IS_KEY(false);
    cst_target_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_target_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_target_node.detail().name("target_node");

    type_object->complete().struct_type().member_seq().emplace_back(cst_target_node);

    CompleteStructMember cst_source_node;
    cst_source_node.common().member_id(memberId++);
    cst_source_node.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_source_node.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_source_node.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_source_node.common().member_flags().IS_OPTIONAL(false);
    cst_source_node.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_source_node.common().member_flags().IS_KEY(true);
    cst_source_node.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_source_node.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_source_node.detail().name("source_node");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_source_node.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_source_node);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("NodeControlImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("NodeControlImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("NodeControlImpl", true);
}

const TypeIdentifier* GetUserInputImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UserInputImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUserInputImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UserInputImpl", complete);
}

const TypeObject* GetUserInputImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUserInputImplObject();
    }
    //else
    return GetMinimalUserInputImplObject();
}

const TypeObject* GetMinimalUserInputImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_modality;
    mst_modality.common().member_id(memberId++);
    mst_modality.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_modality.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_modality.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_modality.common().member_flags().IS_OPTIONAL(false);
    mst_modality.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_modality.common().member_flags().IS_KEY(false);
    mst_modality.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_modality.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 modality_hash("modality");
    for (int i = 0; i < 4; ++i)
    {
        mst_modality.detail().name_hash()[i] = modality_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_modality);

    MinimalStructMember mst_problem_short_description;
    mst_problem_short_description.common().member_id(memberId++);
    mst_problem_short_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_problem_short_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_problem_short_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_problem_short_description.common().member_flags().IS_OPTIONAL(false);
    mst_problem_short_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_problem_short_description.common().member_flags().IS_KEY(false);
    mst_problem_short_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_problem_short_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 problem_short_description_hash("problem_short_description");
    for (int i = 0; i < 4; ++i)
    {
        mst_problem_short_description.detail().name_hash()[i] = problem_short_description_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_problem_short_description);

    MinimalStructMember mst_problem_definition;
    mst_problem_definition.common().member_id(memberId++);
    mst_problem_definition.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_problem_definition.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_problem_definition.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_problem_definition.common().member_flags().IS_OPTIONAL(false);
    mst_problem_definition.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_problem_definition.common().member_flags().IS_KEY(false);
    mst_problem_definition.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_problem_definition.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 problem_definition_hash("problem_definition");
    for (int i = 0; i < 4; ++i)
    {
        mst_problem_definition.detail().name_hash()[i] = problem_definition_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_problem_definition);

    MinimalStructMember mst_inputs;
    mst_inputs.common().member_id(memberId++);
    mst_inputs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_inputs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_inputs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_inputs.common().member_flags().IS_OPTIONAL(false);
    mst_inputs.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_inputs.common().member_flags().IS_KEY(false);
    mst_inputs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_inputs.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::
                    get_string_type_name(255, false), 100, false));

    MD5 inputs_hash("inputs");
    for (int i = 0; i < 4; ++i)
    {
        mst_inputs.detail().name_hash()[i] = inputs_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_inputs);

    MinimalStructMember mst_outputs;
    mst_outputs.common().member_id(memberId++);
    mst_outputs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_outputs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_outputs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_outputs.common().member_flags().IS_OPTIONAL(false);
    mst_outputs.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_outputs.common().member_flags().IS_KEY(false);
    mst_outputs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_outputs.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::
                    get_string_type_name(255, false), 100, false));

    MD5 outputs_hash("outputs");
    for (int i = 0; i < 4; ++i)
    {
        mst_outputs.detail().name_hash()[i] = outputs_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_outputs);

    MinimalStructMember mst_minimum_samples;
    mst_minimum_samples.common().member_id(memberId++);
    mst_minimum_samples.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_minimum_samples.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_minimum_samples.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_minimum_samples.common().member_flags().IS_OPTIONAL(false);
    mst_minimum_samples.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_minimum_samples.common().member_flags().IS_KEY(false);
    mst_minimum_samples.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_minimum_samples.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    MD5 minimum_samples_hash("minimum_samples");
    for (int i = 0; i < 4; ++i)
    {
        mst_minimum_samples.detail().name_hash()[i] = minimum_samples_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_minimum_samples);

    MinimalStructMember mst_maximum_samples;
    mst_maximum_samples.common().member_id(memberId++);
    mst_maximum_samples.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_maximum_samples.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_maximum_samples.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_maximum_samples.common().member_flags().IS_OPTIONAL(false);
    mst_maximum_samples.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_maximum_samples.common().member_flags().IS_KEY(false);
    mst_maximum_samples.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_maximum_samples.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    MD5 maximum_samples_hash("maximum_samples");
    for (int i = 0; i < 4; ++i)
    {
        mst_maximum_samples.detail().name_hash()[i] = maximum_samples_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_maximum_samples);

    MinimalStructMember mst_optimize_carbon_footprint_manual;
    mst_optimize_carbon_footprint_manual.common().member_id(memberId++);
    mst_optimize_carbon_footprint_manual.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_optimize_carbon_footprint_manual.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_optimize_carbon_footprint_manual.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_optimize_carbon_footprint_manual.common().member_flags().IS_OPTIONAL(false);
    mst_optimize_carbon_footprint_manual.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_optimize_carbon_footprint_manual.common().member_flags().IS_KEY(false);
    mst_optimize_carbon_footprint_manual.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_optimize_carbon_footprint_manual.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "bool",
                false));


    MD5 optimize_carbon_footprint_manual_hash("optimize_carbon_footprint_manual");
    for (int i = 0; i < 4; ++i)
    {
        mst_optimize_carbon_footprint_manual.detail().name_hash()[i] = optimize_carbon_footprint_manual_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_optimize_carbon_footprint_manual);

    MinimalStructMember mst_previous_iteration;
    mst_previous_iteration.common().member_id(memberId++);
    mst_previous_iteration.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_previous_iteration.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_previous_iteration.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_previous_iteration.common().member_flags().IS_OPTIONAL(false);
    mst_previous_iteration.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_previous_iteration.common().member_flags().IS_KEY(false);
    mst_previous_iteration.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_previous_iteration.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t",
            false));


    MD5 previous_iteration_hash("previous_iteration");
    for (int i = 0; i < 4; ++i)
    {
        mst_previous_iteration.detail().name_hash()[i] = previous_iteration_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_previous_iteration);

    MinimalStructMember mst_optimize_carbon_footprint_auto;
    mst_optimize_carbon_footprint_auto.common().member_id(memberId++);
    mst_optimize_carbon_footprint_auto.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_optimize_carbon_footprint_auto.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_optimize_carbon_footprint_auto.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_optimize_carbon_footprint_auto.common().member_flags().IS_OPTIONAL(false);
    mst_optimize_carbon_footprint_auto.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_optimize_carbon_footprint_auto.common().member_flags().IS_KEY(false);
    mst_optimize_carbon_footprint_auto.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_optimize_carbon_footprint_auto.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "bool", false));


    MD5 optimize_carbon_footprint_auto_hash("optimize_carbon_footprint_auto");
    for (int i = 0; i < 4; ++i)
    {
        mst_optimize_carbon_footprint_auto.detail().name_hash()[i] = optimize_carbon_footprint_auto_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_optimize_carbon_footprint_auto);

    MinimalStructMember mst_desired_carbon_footprint;
    mst_desired_carbon_footprint.common().member_id(memberId++);
    mst_desired_carbon_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_desired_carbon_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_desired_carbon_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_desired_carbon_footprint.common().member_flags().IS_OPTIONAL(false);
    mst_desired_carbon_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_desired_carbon_footprint.common().member_flags().IS_KEY(false);
    mst_desired_carbon_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_desired_carbon_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "double", false));


    MD5 desired_carbon_footprint_hash("desired_carbon_footprint");
    for (int i = 0; i < 4; ++i)
    {
        mst_desired_carbon_footprint.detail().name_hash()[i] = desired_carbon_footprint_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_desired_carbon_footprint);

    MinimalStructMember mst_geo_location_continent;
    mst_geo_location_continent.common().member_id(memberId++);
    mst_geo_location_continent.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_geo_location_continent.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_geo_location_continent.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_geo_location_continent.common().member_flags().IS_OPTIONAL(false);
    mst_geo_location_continent.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_geo_location_continent.common().member_flags().IS_KEY(false);
    mst_geo_location_continent.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_geo_location_continent.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 geo_location_continent_hash("geo_location_continent");
    for (int i = 0; i < 4; ++i)
    {
        mst_geo_location_continent.detail().name_hash()[i] = geo_location_continent_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_geo_location_continent);

    MinimalStructMember mst_geo_location_region;
    mst_geo_location_region.common().member_id(memberId++);
    mst_geo_location_region.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_geo_location_region.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_geo_location_region.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_geo_location_region.common().member_flags().IS_OPTIONAL(false);
    mst_geo_location_region.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_geo_location_region.common().member_flags().IS_KEY(false);
    mst_geo_location_region.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_geo_location_region.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 geo_location_region_hash("geo_location_region");
    for (int i = 0; i < 4; ++i)
    {
        mst_geo_location_region.detail().name_hash()[i] = geo_location_region_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_geo_location_region);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UserInputImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", false);
}

const TypeObject* GetCompleteUserInputImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_modality;
    cst_modality.common().member_id(memberId++);
    cst_modality.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_modality.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_modality.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_modality.common().member_flags().IS_OPTIONAL(false);
    cst_modality.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_modality.common().member_flags().IS_KEY(false);
    cst_modality.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_modality.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_modality.detail().name("modality");

    type_object->complete().struct_type().member_seq().emplace_back(cst_modality);

    CompleteStructMember cst_problem_short_description;
    cst_problem_short_description.common().member_id(memberId++);
    cst_problem_short_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_problem_short_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_problem_short_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_problem_short_description.common().member_flags().IS_OPTIONAL(false);
    cst_problem_short_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_problem_short_description.common().member_flags().IS_KEY(false);
    cst_problem_short_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_problem_short_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_problem_short_description.detail().name("problem_short_description");

    type_object->complete().struct_type().member_seq().emplace_back(cst_problem_short_description);

    CompleteStructMember cst_problem_definition;
    cst_problem_definition.common().member_id(memberId++);
    cst_problem_definition.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_problem_definition.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_problem_definition.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_problem_definition.common().member_flags().IS_OPTIONAL(false);
    cst_problem_definition.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_problem_definition.common().member_flags().IS_KEY(false);
    cst_problem_definition.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_problem_definition.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_problem_definition.detail().name("problem_definition");

    type_object->complete().struct_type().member_seq().emplace_back(cst_problem_definition);

    CompleteStructMember cst_inputs;
    cst_inputs.common().member_id(memberId++);
    cst_inputs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_inputs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_inputs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_inputs.common().member_flags().IS_OPTIONAL(false);
    cst_inputs.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_inputs.common().member_flags().IS_KEY(false);
    cst_inputs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_inputs.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::
                    get_string_type_name(255, false), 100, true));

    cst_inputs.detail().name("inputs");

    type_object->complete().struct_type().member_seq().emplace_back(cst_inputs);

    CompleteStructMember cst_outputs;
    cst_outputs.common().member_id(memberId++);
    cst_outputs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_outputs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_outputs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_outputs.common().member_flags().IS_OPTIONAL(false);
    cst_outputs.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_outputs.common().member_flags().IS_KEY(false);
    cst_outputs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_outputs.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::
                    get_string_type_name(255, false), 100, true));

    cst_outputs.detail().name("outputs");

    type_object->complete().struct_type().member_seq().emplace_back(cst_outputs);

    CompleteStructMember cst_minimum_samples;
    cst_minimum_samples.common().member_id(memberId++);
    cst_minimum_samples.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_minimum_samples.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_minimum_samples.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_minimum_samples.common().member_flags().IS_OPTIONAL(false);
    cst_minimum_samples.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_minimum_samples.common().member_flags().IS_KEY(false);
    cst_minimum_samples.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_minimum_samples.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    cst_minimum_samples.detail().name("minimum_samples");

    type_object->complete().struct_type().member_seq().emplace_back(cst_minimum_samples);

    CompleteStructMember cst_maximum_samples;
    cst_maximum_samples.common().member_id(memberId++);
    cst_maximum_samples.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_maximum_samples.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_maximum_samples.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_maximum_samples.common().member_flags().IS_OPTIONAL(false);
    cst_maximum_samples.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_maximum_samples.common().member_flags().IS_KEY(false);
    cst_maximum_samples.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_maximum_samples.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    cst_maximum_samples.detail().name("maximum_samples");

    type_object->complete().struct_type().member_seq().emplace_back(cst_maximum_samples);

    CompleteStructMember cst_optimize_carbon_footprint_manual;
    cst_optimize_carbon_footprint_manual.common().member_id(memberId++);
    cst_optimize_carbon_footprint_manual.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_optimize_carbon_footprint_manual.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_optimize_carbon_footprint_manual.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_optimize_carbon_footprint_manual.common().member_flags().IS_OPTIONAL(false);
    cst_optimize_carbon_footprint_manual.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_optimize_carbon_footprint_manual.common().member_flags().IS_KEY(false);
    cst_optimize_carbon_footprint_manual.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_optimize_carbon_footprint_manual.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "bool",
                false));


    cst_optimize_carbon_footprint_manual.detail().name("optimize_carbon_footprint_manual");

    type_object->complete().struct_type().member_seq().emplace_back(cst_optimize_carbon_footprint_manual);

    CompleteStructMember cst_previous_iteration;
    cst_previous_iteration.common().member_id(memberId++);
    cst_previous_iteration.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_previous_iteration.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_previous_iteration.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_previous_iteration.common().member_flags().IS_OPTIONAL(false);
    cst_previous_iteration.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_previous_iteration.common().member_flags().IS_KEY(false);
    cst_previous_iteration.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_previous_iteration.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t",
            false));


    cst_previous_iteration.detail().name("previous_iteration");

    type_object->complete().struct_type().member_seq().emplace_back(cst_previous_iteration);

    CompleteStructMember cst_optimize_carbon_footprint_auto;
    cst_optimize_carbon_footprint_auto.common().member_id(memberId++);
    cst_optimize_carbon_footprint_auto.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_optimize_carbon_footprint_auto.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_optimize_carbon_footprint_auto.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_optimize_carbon_footprint_auto.common().member_flags().IS_OPTIONAL(false);
    cst_optimize_carbon_footprint_auto.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_optimize_carbon_footprint_auto.common().member_flags().IS_KEY(false);
    cst_optimize_carbon_footprint_auto.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_optimize_carbon_footprint_auto.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "bool", false));


    cst_optimize_carbon_footprint_auto.detail().name("optimize_carbon_footprint_auto");

    type_object->complete().struct_type().member_seq().emplace_back(cst_optimize_carbon_footprint_auto);

    CompleteStructMember cst_desired_carbon_footprint;
    cst_desired_carbon_footprint.common().member_id(memberId++);
    cst_desired_carbon_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_desired_carbon_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_desired_carbon_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_desired_carbon_footprint.common().member_flags().IS_OPTIONAL(false);
    cst_desired_carbon_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_desired_carbon_footprint.common().member_flags().IS_KEY(false);
    cst_desired_carbon_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_desired_carbon_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "double", false));


    cst_desired_carbon_footprint.detail().name("desired_carbon_footprint");

    type_object->complete().struct_type().member_seq().emplace_back(cst_desired_carbon_footprint);

    CompleteStructMember cst_geo_location_continent;
    cst_geo_location_continent.common().member_id(memberId++);
    cst_geo_location_continent.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_geo_location_continent.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_geo_location_continent.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_geo_location_continent.common().member_flags().IS_OPTIONAL(false);
    cst_geo_location_continent.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_geo_location_continent.common().member_flags().IS_KEY(false);
    cst_geo_location_continent.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_geo_location_continent.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_geo_location_continent.detail().name("geo_location_continent");

    type_object->complete().struct_type().member_seq().emplace_back(cst_geo_location_continent);

    CompleteStructMember cst_geo_location_region;
    cst_geo_location_region.common().member_id(memberId++);
    cst_geo_location_region.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_geo_location_region.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_geo_location_region.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_geo_location_region.common().member_flags().IS_OPTIONAL(false);
    cst_geo_location_region.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_geo_location_region.common().member_flags().IS_KEY(false);
    cst_geo_location_region.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_geo_location_region.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_geo_location_region.detail().name("geo_location_region");

    type_object->complete().struct_type().member_seq().emplace_back(cst_geo_location_region);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UserInputImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UserInputImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UserInputImpl", true);
}

const TypeIdentifier* GetMLModelMetadataImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MLModelMetadataImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMLModelMetadataImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MLModelMetadataImpl", complete);
}

const TypeObject* GetMLModelMetadataImplObject(
        bool complete)
{
    const TypeObject* c_type_object =
            TypeObjectFactory::get_instance()->get_type_object("MLModelMetadataImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMLModelMetadataImplObject();
    }
    //else
    return GetMinimalMLModelMetadataImplObject();
}

const TypeObject* GetMinimalMLModelMetadataImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelMetadataImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_keywords;
    mst_keywords.common().member_id(memberId++);
    mst_keywords.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_keywords.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_keywords.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_keywords.common().member_flags().IS_OPTIONAL(false);
    mst_keywords.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_keywords.common().member_flags().IS_KEY(false);
    mst_keywords.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_keywords.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator
                    ::get_string_type_name(255, false), 100, false));

    MD5 keywords_hash("keywords");
    for (int i = 0; i < 4; ++i)
    {
        mst_keywords.detail().name_hash()[i] = keywords_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_keywords);

    MinimalStructMember mst_ml_model_metadata;
    mst_ml_model_metadata.common().member_id(memberId++);
    mst_ml_model_metadata.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_ml_model_metadata.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_ml_model_metadata.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_ml_model_metadata.common().member_flags().IS_OPTIONAL(false);
    mst_ml_model_metadata.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_ml_model_metadata.common().member_flags().IS_KEY(false);
    mst_ml_model_metadata.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_ml_model_metadata.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(
                TypeNamesGenerator::get_string_type_name(255, false), 100, false));

    MD5 ml_model_metadata_hash("ml_model_metadata");
    for (int i = 0; i < 4; ++i)
    {
        mst_ml_model_metadata.detail().name_hash()[i] = ml_model_metadata_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_ml_model_metadata);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MLModelMetadataImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MLModelMetadataImpl", false);
}

const TypeObject* GetCompleteMLModelMetadataImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelMetadataImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_keywords;
    cst_keywords.common().member_id(memberId++);
    cst_keywords.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_keywords.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_keywords.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_keywords.common().member_flags().IS_OPTIONAL(false);
    cst_keywords.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_keywords.common().member_flags().IS_KEY(false);
    cst_keywords.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_keywords.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator
                    ::get_string_type_name(255, false), 100, true));

    cst_keywords.detail().name("keywords");

    type_object->complete().struct_type().member_seq().emplace_back(cst_keywords);

    CompleteStructMember cst_ml_model_metadata;
    cst_ml_model_metadata.common().member_id(memberId++);
    cst_ml_model_metadata.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_ml_model_metadata.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_ml_model_metadata.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_ml_model_metadata.common().member_flags().IS_OPTIONAL(false);
    cst_ml_model_metadata.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_ml_model_metadata.common().member_flags().IS_KEY(false);
    cst_ml_model_metadata.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_ml_model_metadata.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(
                TypeNamesGenerator::get_string_type_name(255, false), 100, true));

    cst_ml_model_metadata.detail().name("ml_model_metadata");

    type_object->complete().struct_type().member_seq().emplace_back(cst_ml_model_metadata);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MLModelMetadataImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MLModelMetadataImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MLModelMetadataImpl", true);
}

const TypeIdentifier* GetAppRequirementsImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppRequirementsImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppRequirementsImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppRequirementsImpl", complete);
}

const TypeObject* GetAppRequirementsImplObject(
        bool complete)
{
    const TypeObject* c_type_object =
            TypeObjectFactory::get_instance()->get_type_object("AppRequirementsImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppRequirementsImplObject();
    }
    //else
    return GetMinimalAppRequirementsImplObject();
}

const TypeObject* GetMinimalAppRequirementsImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppRequirementsImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_app_requirements;
    mst_app_requirements.common().member_id(memberId++);
    mst_app_requirements.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_app_requirements.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_app_requirements.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_app_requirements.common().member_flags().IS_OPTIONAL(false);
    mst_app_requirements.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_app_requirements.common().member_flags().IS_KEY(false);
    mst_app_requirements.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_app_requirements.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(
                TypeNamesGenerator::get_string_type_name(255, false), 100, false));

    MD5 app_requirements_hash("app_requirements");
    for (int i = 0; i < 4; ++i)
    {
        mst_app_requirements.detail().name_hash()[i] = app_requirements_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_app_requirements);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppRequirementsImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppRequirementsImpl", false);
}

const TypeObject* GetCompleteAppRequirementsImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppRequirementsImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_app_requirements;
    cst_app_requirements.common().member_id(memberId++);
    cst_app_requirements.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_app_requirements.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_app_requirements.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_app_requirements.common().member_flags().IS_OPTIONAL(false);
    cst_app_requirements.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_app_requirements.common().member_flags().IS_KEY(false);
    cst_app_requirements.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_app_requirements.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(
                TypeNamesGenerator::get_string_type_name(255, false), 100, true));

    cst_app_requirements.detail().name("app_requirements");

    type_object->complete().struct_type().member_seq().emplace_back(cst_app_requirements);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppRequirementsImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppRequirementsImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppRequirementsImpl", true);
}

const TypeIdentifier* GetHWConstraintsImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("HWConstraintsImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetHWConstraintsImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("HWConstraintsImpl", complete);
}

const TypeObject* GetHWConstraintsImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWConstraintsImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteHWConstraintsImplObject();
    }
    //else
    return GetMinimalHWConstraintsImplObject();
}

const TypeObject* GetMinimalHWConstraintsImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWConstraintsImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_max_memory_footprint;
    mst_max_memory_footprint.common().member_id(memberId++);
    mst_max_memory_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_max_memory_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_max_memory_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_max_memory_footprint.common().member_flags().IS_OPTIONAL(false);
    mst_max_memory_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_max_memory_footprint.common().member_flags().IS_KEY(false);
    mst_max_memory_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_max_memory_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    MD5 max_memory_footprint_hash("max_memory_footprint");
    for (int i = 0; i < 4; ++i)
    {
        mst_max_memory_footprint.detail().name_hash()[i] = max_memory_footprint_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_max_memory_footprint);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("HWConstraintsImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("HWConstraintsImpl", false);
}

const TypeObject* GetCompleteHWConstraintsImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWConstraintsImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_max_memory_footprint;
    cst_max_memory_footprint.common().member_id(memberId++);
    cst_max_memory_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_max_memory_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_max_memory_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_max_memory_footprint.common().member_flags().IS_OPTIONAL(false);
    cst_max_memory_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_max_memory_footprint.common().member_flags().IS_KEY(false);
    cst_max_memory_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_max_memory_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t",
            false));


    cst_max_memory_footprint.detail().name("max_memory_footprint");

    type_object->complete().struct_type().member_seq().emplace_back(cst_max_memory_footprint);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("HWConstraintsImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("HWConstraintsImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("HWConstraintsImpl", true);
}

const TypeIdentifier* GetMLModelImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier =
            TypeObjectFactory::get_instance()->get_type_identifier("MLModelImpl", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMLModelImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MLModelImpl", complete);
}

const TypeObject* GetMLModelImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMLModelImplObject();
    }
    //else
    return GetMinimalMLModelImplObject();
}

const TypeObject* GetMinimalMLModelImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_model_path;
    mst_model_path.common().member_id(memberId++);
    mst_model_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model_path.common().member_flags().IS_OPTIONAL(false);
    mst_model_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model_path.common().member_flags().IS_KEY(false);
    mst_model_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 model_path_hash("model_path");
    for (int i = 0; i < 4; ++i)
    {
        mst_model_path.detail().name_hash()[i] = model_path_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model_path);

    MinimalStructMember mst_model;
    mst_model.common().member_id(memberId++);
    mst_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model.common().member_flags().IS_OPTIONAL(false);
    mst_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model.common().member_flags().IS_KEY(false);
    mst_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 model_hash("model");
    for (int i = 0; i < 4; ++i)
    {
        mst_model.detail().name_hash()[i] = model_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model);

    MinimalStructMember mst_raw_model;
    mst_raw_model.common().member_id(memberId++);
    mst_raw_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_raw_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_raw_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_raw_model.common().member_flags().IS_OPTIONAL(false);
    mst_raw_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_raw_model.common().member_flags().IS_KEY(false);
    mst_raw_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_raw_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 raw_model_hash("raw_model");
    for (int i = 0; i < 4; ++i)
    {
        mst_raw_model.detail().name_hash()[i] = raw_model_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_raw_model);

    MinimalStructMember mst_model_properties_path;
    mst_model_properties_path.common().member_id(memberId++);
    mst_model_properties_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model_properties_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model_properties_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model_properties_path.common().member_flags().IS_OPTIONAL(false);
    mst_model_properties_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model_properties_path.common().member_flags().IS_KEY(false);
    mst_model_properties_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model_properties_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    MD5 model_properties_path_hash("model_properties_path");
    for (int i = 0; i < 4; ++i)
    {
        mst_model_properties_path.detail().name_hash()[i] = model_properties_path_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model_properties_path);

    MinimalStructMember mst_model_properties;
    mst_model_properties.common().member_id(memberId++);
    mst_model_properties.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_model_properties.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_model_properties.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_model_properties.common().member_flags().IS_OPTIONAL(false);
    mst_model_properties.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_model_properties.common().member_flags().IS_KEY(false);
    mst_model_properties.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_model_properties.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 model_properties_hash("model_properties");
    for (int i = 0; i < 4; ++i)
    {
        mst_model_properties.detail().name_hash()[i] = model_properties_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_model_properties);

    MinimalStructMember mst_input_batch;
    mst_input_batch.common().member_id(memberId++);
    mst_input_batch.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_input_batch.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_input_batch.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_input_batch.common().member_flags().IS_OPTIONAL(false);
    mst_input_batch.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_input_batch.common().member_flags().IS_KEY(false);
    mst_input_batch.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_input_batch.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(
                TypeNamesGenerator::get_string_type_name(255, false), 100, false));

    MD5 input_batch_hash("input_batch");
    for (int i = 0; i < 4; ++i)
    {
        mst_input_batch.detail().name_hash()[i] = input_batch_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_input_batch);

    MinimalStructMember mst_target_latency;
    mst_target_latency.common().member_id(memberId++);
    mst_target_latency.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_target_latency.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_target_latency.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_target_latency.common().member_flags().IS_OPTIONAL(false);
    mst_target_latency.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_target_latency.common().member_flags().IS_KEY(false);
    mst_target_latency.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_target_latency.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 target_latency_hash("target_latency");
    for (int i = 0; i < 4; ++i)
    {
        mst_target_latency.detail().name_hash()[i] = target_latency_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_target_latency);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MLModelImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", false);
}

const TypeObject* GetCompleteMLModelImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_model_path;
    cst_model_path.common().member_id(memberId++);
    cst_model_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model_path.common().member_flags().IS_OPTIONAL(false);
    cst_model_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model_path.common().member_flags().IS_KEY(false);
    cst_model_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_model_path.detail().name("model_path");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model_path);

    CompleteStructMember cst_model;
    cst_model.common().member_id(memberId++);
    cst_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model.common().member_flags().IS_OPTIONAL(false);
    cst_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model.common().member_flags().IS_KEY(false);
    cst_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_model.detail().name("model");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model);

    CompleteStructMember cst_raw_model;
    cst_raw_model.common().member_id(memberId++);
    cst_raw_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_raw_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_raw_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_raw_model.common().member_flags().IS_OPTIONAL(false);
    cst_raw_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_raw_model.common().member_flags().IS_KEY(false);
    cst_raw_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_raw_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_raw_model.detail().name("raw_model");

    type_object->complete().struct_type().member_seq().emplace_back(cst_raw_model);

    CompleteStructMember cst_model_properties_path;
    cst_model_properties_path.common().member_id(memberId++);
    cst_model_properties_path.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model_properties_path.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model_properties_path.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model_properties_path.common().member_flags().IS_OPTIONAL(false);
    cst_model_properties_path.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model_properties_path.common().member_flags().IS_KEY(false);
    cst_model_properties_path.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model_properties_path.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255,
            false));

    cst_model_properties_path.detail().name("model_properties_path");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model_properties_path);

    CompleteStructMember cst_model_properties;
    cst_model_properties.common().member_id(memberId++);
    cst_model_properties.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_model_properties.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_model_properties.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_model_properties.common().member_flags().IS_OPTIONAL(false);
    cst_model_properties.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_model_properties.common().member_flags().IS_KEY(false);
    cst_model_properties.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_model_properties.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_model_properties.detail().name("model_properties");

    type_object->complete().struct_type().member_seq().emplace_back(cst_model_properties);

    CompleteStructMember cst_input_batch;
    cst_input_batch.common().member_id(memberId++);
    cst_input_batch.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_input_batch.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_input_batch.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_input_batch.common().member_flags().IS_OPTIONAL(false);
    cst_input_batch.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_input_batch.common().member_flags().IS_KEY(false);
    cst_input_batch.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_input_batch.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(
                TypeNamesGenerator::get_string_type_name(255, false), 100, true));

    cst_input_batch.detail().name("input_batch");

    type_object->complete().struct_type().member_seq().emplace_back(cst_input_batch);

    CompleteStructMember cst_target_latency;
    cst_target_latency.common().member_id(memberId++);
    cst_target_latency.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_target_latency.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_target_latency.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_target_latency.common().member_flags().IS_OPTIONAL(false);
    cst_target_latency.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_target_latency.common().member_flags().IS_KEY(false);
    cst_target_latency.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_target_latency.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_target_latency.detail().name("target_latency");

    type_object->complete().struct_type().member_seq().emplace_back(cst_target_latency);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MLModelImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MLModelImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MLModelImpl", true);
}

const TypeIdentifier* GetHWResourceImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("HWResourceImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetHWResourceImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("HWResourceImpl", complete);
}

const TypeObject* GetHWResourceImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteHWResourceImplObject();
    }
    //else
    return GetMinimalHWResourceImplObject();
}

const TypeObject* GetMinimalHWResourceImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_hw_description;
    mst_hw_description.common().member_id(memberId++);
    mst_hw_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_hw_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_hw_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_hw_description.common().member_flags().IS_OPTIONAL(false);
    mst_hw_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_hw_description.common().member_flags().IS_KEY(false);
    mst_hw_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_hw_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    MD5 hw_description_hash("hw_description");
    for (int i = 0; i < 4; ++i)
    {
        mst_hw_description.detail().name_hash()[i] = hw_description_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_hw_description);

    MinimalStructMember mst_power_consumption;
    mst_power_consumption.common().member_id(memberId++);
    mst_power_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_power_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_power_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_power_consumption.common().member_flags().IS_OPTIONAL(false);
    mst_power_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_power_consumption.common().member_flags().IS_KEY(false);
    mst_power_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_power_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 power_consumption_hash("power_consumption");
    for (int i = 0; i < 4; ++i)
    {
        mst_power_consumption.detail().name_hash()[i] = power_consumption_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_power_consumption);

    MinimalStructMember mst_latency;
    mst_latency.common().member_id(memberId++);
    mst_latency.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_latency.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_latency.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_latency.common().member_flags().IS_OPTIONAL(false);
    mst_latency.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_latency.common().member_flags().IS_KEY(false);
    mst_latency.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_latency.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));


    MD5 latency_hash("latency");
    for (int i = 0; i < 4; ++i)
    {
        mst_latency.detail().name_hash()[i] = latency_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_latency);

    MinimalStructMember mst_memory_footprint_of_ml_model;
    mst_memory_footprint_of_ml_model.common().member_id(memberId++);
    mst_memory_footprint_of_ml_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_memory_footprint_of_ml_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_memory_footprint_of_ml_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_memory_footprint_of_ml_model.common().member_flags().IS_OPTIONAL(false);
    mst_memory_footprint_of_ml_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_memory_footprint_of_ml_model.common().member_flags().IS_KEY(false);
    mst_memory_footprint_of_ml_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_memory_footprint_of_ml_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "double", false));


    MD5 memory_footprint_of_ml_model_hash("memory_footprint_of_ml_model");
    for (int i = 0; i < 4; ++i)
    {
        mst_memory_footprint_of_ml_model.detail().name_hash()[i] = memory_footprint_of_ml_model_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_memory_footprint_of_ml_model);

    MinimalStructMember mst_max_hw_memory_footprint;
    mst_max_hw_memory_footprint.common().member_id(memberId++);
    mst_max_hw_memory_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_max_hw_memory_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_max_hw_memory_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_max_hw_memory_footprint.common().member_flags().IS_OPTIONAL(false);
    mst_max_hw_memory_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_max_hw_memory_footprint.common().member_flags().IS_KEY(false);
    mst_max_hw_memory_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_max_hw_memory_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 max_hw_memory_footprint_hash("max_hw_memory_footprint");
    for (int i = 0; i < 4; ++i)
    {
        mst_max_hw_memory_footprint.detail().name_hash()[i] = max_hw_memory_footprint_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_max_hw_memory_footprint);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("HWResourceImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", false);
}

const TypeObject* GetCompleteHWResourceImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_hw_description;
    cst_hw_description.common().member_id(memberId++);
    cst_hw_description.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_hw_description.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_hw_description.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_hw_description.common().member_flags().IS_OPTIONAL(false);
    cst_hw_description.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_hw_description.common().member_flags().IS_KEY(false);
    cst_hw_description.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_hw_description.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_hw_description.detail().name("hw_description");

    type_object->complete().struct_type().member_seq().emplace_back(cst_hw_description);

    CompleteStructMember cst_power_consumption;
    cst_power_consumption.common().member_id(memberId++);
    cst_power_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_power_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_power_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_power_consumption.common().member_flags().IS_OPTIONAL(false);
    cst_power_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_power_consumption.common().member_flags().IS_KEY(false);
    cst_power_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_power_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_power_consumption.detail().name("power_consumption");

    type_object->complete().struct_type().member_seq().emplace_back(cst_power_consumption);

    CompleteStructMember cst_latency;
    cst_latency.common().member_id(memberId++);
    cst_latency.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_latency.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_latency.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_latency.common().member_flags().IS_OPTIONAL(false);
    cst_latency.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_latency.common().member_flags().IS_KEY(false);
    cst_latency.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_latency.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));


    cst_latency.detail().name("latency");

    type_object->complete().struct_type().member_seq().emplace_back(cst_latency);

    CompleteStructMember cst_memory_footprint_of_ml_model;
    cst_memory_footprint_of_ml_model.common().member_id(memberId++);
    cst_memory_footprint_of_ml_model.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_memory_footprint_of_ml_model.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_memory_footprint_of_ml_model.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_memory_footprint_of_ml_model.common().member_flags().IS_OPTIONAL(false);
    cst_memory_footprint_of_ml_model.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_memory_footprint_of_ml_model.common().member_flags().IS_KEY(false);
    cst_memory_footprint_of_ml_model.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_memory_footprint_of_ml_model.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier(
                "double", false));


    cst_memory_footprint_of_ml_model.detail().name("memory_footprint_of_ml_model");

    type_object->complete().struct_type().member_seq().emplace_back(cst_memory_footprint_of_ml_model);

    CompleteStructMember cst_max_hw_memory_footprint;
    cst_max_hw_memory_footprint.common().member_id(memberId++);
    cst_max_hw_memory_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_max_hw_memory_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_max_hw_memory_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_max_hw_memory_footprint.common().member_flags().IS_OPTIONAL(false);
    cst_max_hw_memory_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_max_hw_memory_footprint.common().member_flags().IS_KEY(false);
    cst_max_hw_memory_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_max_hw_memory_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_max_hw_memory_footprint.detail().name("max_hw_memory_footprint");

    type_object->complete().struct_type().member_seq().emplace_back(cst_max_hw_memory_footprint);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("HWResourceImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("HWResourceImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("HWResourceImpl", true);
}

const TypeIdentifier* GetCO2FootprintImplIdentifier(
        bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CO2FootprintImpl",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCO2FootprintImplObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CO2FootprintImpl", complete);
}

const TypeObject* GetCO2FootprintImplObject(
        bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCO2FootprintImplObject();
    }
    //else
    return GetMinimalCO2FootprintImplObject();
}

const TypeObject* GetMinimalCO2FootprintImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_carbon_footprint;
    mst_carbon_footprint.common().member_id(memberId++);
    mst_carbon_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_carbon_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_carbon_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_carbon_footprint.common().member_flags().IS_OPTIONAL(false);
    mst_carbon_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_carbon_footprint.common().member_flags().IS_KEY(false);
    mst_carbon_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_carbon_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 carbon_footprint_hash("carbon_footprint");
    for (int i = 0; i < 4; ++i)
    {
        mst_carbon_footprint.detail().name_hash()[i] = carbon_footprint_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_carbon_footprint);

    MinimalStructMember mst_energy_consumption;
    mst_energy_consumption.common().member_id(memberId++);
    mst_energy_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_energy_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_energy_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_energy_consumption.common().member_flags().IS_OPTIONAL(false);
    mst_energy_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_energy_consumption.common().member_flags().IS_KEY(false);
    mst_energy_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_energy_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 energy_consumption_hash("energy_consumption");
    for (int i = 0; i < 4; ++i)
    {
        mst_energy_consumption.detail().name_hash()[i] = energy_consumption_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_energy_consumption);

    MinimalStructMember mst_carbon_intensity;
    mst_carbon_intensity.common().member_id(memberId++);
    mst_carbon_intensity.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_carbon_intensity.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_carbon_intensity.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_carbon_intensity.common().member_flags().IS_OPTIONAL(false);
    mst_carbon_intensity.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_carbon_intensity.common().member_flags().IS_KEY(false);
    mst_carbon_intensity.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_carbon_intensity.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    MD5 carbon_intensity_hash("carbon_intensity");
    for (int i = 0; i < 4; ++i)
    {
        mst_carbon_intensity.detail().name_hash()[i] = carbon_intensity_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_carbon_intensity);

    MinimalStructMember mst_extra_data;
    mst_extra_data.common().member_id(memberId++);
    mst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_extra_data.common().member_flags().IS_OPTIONAL(false);
    mst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_extra_data.common().member_flags().IS_KEY(false);
    mst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            false));

    MD5 extra_data_hash("extra_data");
    for (int i = 0; i < 4; ++i)
    {
        mst_extra_data.detail().name_hash()[i] = extra_data_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_extra_data);

    MinimalStructMember mst_task_id;
    mst_task_id.common().member_id(memberId++);
    mst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_task_id.common().member_flags().IS_OPTIONAL(false);
    mst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_task_id.common().member_flags().IS_KEY(true);
    mst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(false));

    MD5 task_id_hash("task_id");
    for (int i = 0; i < 4; ++i)
    {
        mst_task_id.detail().name_hash()[i] = task_id_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_task_id);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CO2FootprintImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", false);
}

const TypeObject* GetCompleteCO2FootprintImplObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_carbon_footprint;
    cst_carbon_footprint.common().member_id(memberId++);
    cst_carbon_footprint.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_carbon_footprint.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_carbon_footprint.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_carbon_footprint.common().member_flags().IS_OPTIONAL(false);
    cst_carbon_footprint.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_carbon_footprint.common().member_flags().IS_KEY(false);
    cst_carbon_footprint.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_carbon_footprint.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_carbon_footprint.detail().name("carbon_footprint");

    type_object->complete().struct_type().member_seq().emplace_back(cst_carbon_footprint);

    CompleteStructMember cst_energy_consumption;
    cst_energy_consumption.common().member_id(memberId++);
    cst_energy_consumption.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_energy_consumption.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_energy_consumption.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_energy_consumption.common().member_flags().IS_OPTIONAL(false);
    cst_energy_consumption.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_energy_consumption.common().member_flags().IS_KEY(false);
    cst_energy_consumption.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_energy_consumption.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_energy_consumption.detail().name("energy_consumption");

    type_object->complete().struct_type().member_seq().emplace_back(cst_energy_consumption);

    CompleteStructMember cst_carbon_intensity;
    cst_carbon_intensity.common().member_id(memberId++);
    cst_carbon_intensity.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_carbon_intensity.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_carbon_intensity.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_carbon_intensity.common().member_flags().IS_OPTIONAL(false);
    cst_carbon_intensity.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_carbon_intensity.common().member_flags().IS_KEY(false);
    cst_carbon_intensity.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_carbon_intensity.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double",
            false));


    cst_carbon_intensity.detail().name("carbon_intensity");

    type_object->complete().struct_type().member_seq().emplace_back(cst_carbon_intensity);

    CompleteStructMember cst_extra_data;
    cst_extra_data.common().member_id(memberId++);
    cst_extra_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_extra_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_extra_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_extra_data.common().member_flags().IS_OPTIONAL(false);
    cst_extra_data.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_extra_data.common().member_flags().IS_KEY(false);
    cst_extra_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_extra_data.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100,
            true));

    cst_extra_data.detail().name("extra_data");

    type_object->complete().struct_type().member_seq().emplace_back(cst_extra_data);

    CompleteStructMember cst_task_id;
    cst_task_id.common().member_id(memberId++);
    cst_task_id.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_task_id.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_task_id.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_task_id.common().member_flags().IS_OPTIONAL(false);
    cst_task_id.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_task_id.common().member_flags().IS_KEY(true);
    cst_task_id.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_task_id.common().member_type_id(*GetTaskIdImplIdentifier(true));

    cst_task_id.detail().name("task_id");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetkeyIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("key"));
        {
            AppliedAnnotationParameter annParam;
            MD5 message_hash("value");
            for (int i = 0; i < 4; ++i)
            {
                annParam.paramname_hash()[i] = message_hash.digest[i];
            }
            AnnotationParameterValue paramValue;
            paramValue._d(TK_BOOLEAN);
            paramValue.from_string("true");
            annParam.value(paramValue);
            ann.param_seq().push_back(annParam);
        }

        cst_task_id.detail().ann_custom().push_back(ann);
    }


    type_object->complete().struct_type().member_seq().emplace_back(cst_task_id);


    // Header
    type_object->complete().struct_type().header().detail().type_name("CO2FootprintImpl");
    // TODO inheritance
    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CO2FootprintImpl", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CO2FootprintImpl", true);
}
